{"1":{"lang":"NL","title":"Heb je 30 minuten over? Probeer Ruby eens uit!","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Ruby is een programmeertaal uit Japan die software ontwikkeling op zijn kop zet!</p>\n\n<p>Het mooie van Ruby is de balans tussen eenvoud en kracht.</p>\n\n<p>Type wat Ruby code in de editor en gebruik de knoppen om TryRuby te bedienen:</p>\n\n<ul>\n<li><strong>Run</strong> &rarr; Voert de code in de editor uit</li>\n<li><strong>Copy</strong> &rarr; Kopieert de voorbeeld code naar de editor</li>\n<li><strong>Next</strong> &rarr; Naar de volgende les</li>\n<li><strong>Back</strong> &rarr; Ga terug naar de vorige les</li>\n</ul>\n\n<div class=\"foxes\">Klik op <strong>Next</strong> om te beginnen.</div>\n","load_code":""},
"2":{"lang":"NL","title":"De editor","chapter":"N","answer":"^\\d{1,}$","ok":"Heel goed! Je hebt Ruby laten rekenen. Zag je het antwoord verschijnen ?","error":"Type 2 + 6 in de editor","text":"<p>Het editor venster, rechtonder, is de plek om Ruby code in te voeren, tik daarna op de\n<strong>Run</strong> knop om de resultaten te bekijken.</p>\n\n<p>Laten we eens beginnen met wat rekenwerk. Typ bijvoorbeeld dit in:</p>\n\n<pre><code>2 + 6\n</code></pre>\n\n<p>De uitvoer van je programma zou in het &lsquo;output&rsquo; venster rechtsboven moeten\nverschijnen.\nAls het goed is staat er ook een regel bij die je vertelt of je het goed hebt gedaan.</p>\n\n<blockquote>\n<p>Je kunt trouwens ook op de <strong>Copy</strong> knop klikken om de voorbeeldcode naar de editor te\nkopiÃ«ren.</p>\n</blockquote>\n\n<p>Klik op <strong>Next</strong> om naar de volgende les te gaan.</p>\n","load_code":""},
"3":{"lang":"NL","title":"Nummers en symbolen","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Klinkt goed","error":"Type 2 of 3 sommetjes","text":"<p>Ruby herkent numbers en allerlei rekenkundige symbolen.</p>\n\n<p>Probeer nog eens wat sommetjes uit:</p>\n\n<pre><code>4 * 10\n5 - 12\n30 / 4\n</code></pre>\n","load_code":""},
"4":{"lang":"NL","title":"Anders gezegd","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Goed gezegd","error":"Euh","text":"<p>Zag je dat ! Je geeft 3 sommetjes op maar je krijgt alleen het antwoord van de laatste\nsom. Hoe kan dat ?</p>\n\n<blockquote>\n<p>Om deze website zo handig mogelijk te maken heb ik Ruby de opdracht gegeven om het\nresultaat van jouw programma in het output venster te zetten.<br>\nMaar alleen het <strong>laatste resultaat</strong> en alleen als er nog geen andere output is.</p>\n</blockquote>\n\n<p>Dus toen je 3 sommetjes opgaf liet Ruby alleen het antwoord van de laatste zien.</p>\n\n<p>Maar, jij hebt het in je om de uitvoer naar je hand te zetten. Ik voel het gewoon.</p>\n\n<p>Typ <strong>puts</strong> voor iedere som (met een spatie ertussen).</p>\n\n<p>Puts betekent in het Engels: &lsquo;<em>put something on the screen</em>&rsquo;. Oftwel zet <em>iets op\nhet scherm</em>.</p>\n\n<p>Probeer dit eens:</p>\n\n<pre><code>puts 4 * 10\nputs 5 - 12\nputs 30 / 4\n</code></pre>\n\n<p>Haal de <em>puts</em> bij de laatste regel weg. Wat gebeurt er dan?</p>\n","load_code":""},
"5":{"lang":"NL","title":"Hoe heet je ?","chapter":"N","answer":"[a-zA-Z]{1,1}","ok":"Mooi, je hebt een string gemaakt met alle letters van jouw naam","error":"","text":"<p>Ja ja, computers zijn heel handig om mee te rekenen, maar dat kan mijn rekenmachine ook.<br>\nLaten we eens wat anders doen. Wat dacht je van het verdraaien van je naam ?</p>\n\n<p>Type eerst je voornaam in de editor. Zet je naam wel tussen aanhalingstekens, bijvoorbeeld\nzoiets:</p>\n\n<pre><code>&quot;Jantje&quot;\n</code></pre>\n","load_code":""},
"6":{"lang":"NL","title":"Achterstevoren","chapter":"N","answer":"\\w+","ok":"deoG","error":"","text":"<p>Een string is het Engelse woord voor reeks. Een string is dus gewoon een reeks tekens\nwaar een computer iets mee kan.</p>\n\n<blockquote>\n<p>Strings doen mij vaak denken aan een wasdrooglijn waaraan kleren hangen. De\naanhalingstekens aan het begin en einde zijn de wasknijpers.</p>\n</blockquote>\n\n<p>Om je naam om te draaien typ je: </p>\n\n<pre><code>&quot;Jantje&quot;.reverse\n</code></pre>\n\n<p>(Vergeet de punt niet)</p>\n","load_code":""},
"7":{"lang":"NL","title":"Tellen maar","chapter":"N","answer":"^\\d+$","ok":"Ja, 'length' is ook een methode","error":"","text":"<p>Je hebt net je eerste <strong>methode</strong> gebruikt.\n<em>Method</em> op zijn Engels.</p>\n\n<p>Eerst maakte je een string door je naam tussen aanhalingstekens te zetten.\nDaarna gebruikte je de <em>reverse</em> (omdraai) methode om de volgorde van alle\nletters van je naam om te draaien.</p>\n\n<p>Hoeveel letters zitten er eigenlijk in jouw naam ?</p>\n\n<pre><code>&quot;Jantje&quot;.length\n</code></pre>\n","load_code":""},
"8":{"lang":"NL","title":"Op herhaling","chapter":"N","answer":"(\\w+)","ok":"Aangenaam. Aangenaam. Aangenaam. Aangenaam. Aangenaam.","error":"","text":"<p>Je vraagt je misschien af waar dit allemaal goed voor is.</p>\n\n<p>Je hebt vast wel eens ergens een wachtwoord moeten opgeven, om\nals antwoord te krijgen:<br>\n<strong>&ldquo;Hee, je wachtwoord is te kort !&rdquo;</strong></p>\n\n<p>Het programma van die website of app gebruikt ook zo&#39;n simpele\n<strong>lengte</strong> methode.</p>\n\n<p>Heb ik een leuk trucje voor. Vermenigvuldig je naam maar eens met vijf:</p>\n\n<pre><code>&quot;Jantje&quot; * 5\n</code></pre>\n","load_code":""},
"9":{"lang":"NL","title":"Je hebt samenvatting 1 bereikt","chapter":"Y","answer":"NoMethodError|undefined","ok":"Nee, nummers kan je niet omdraaien. Klik 'next'","error":"","text":"<p>Je bent net 1 minuut bezig en kijk eens wat je allemaal al weet.</p>\n\n<h3>De editor</h3>\n\n<p>Code intypen in de editor en op run klikken geeft je een antwoord het output\nvenster. (Bijna) alle code geeft een antwoord. Met <em>puts</em> bepaal je zelf wat\nje wilt tonen.</p>\n\n<h3>Nummers en strings</h3>\n\n<p>Numbers en strings zijn Ruby&rsquo;s reken en tekst objecten.</p>\n\n<h3>Methodes</h3>\n\n<p>Je hebt Engelstalige methodes gebruikt als <em>reverse</em> en <em>length</em>.<br>\nEn symbolische methoden zoals vermenigvuldigen: *<br>\n<strong>Methodes betekenen actie!</strong></p>\n\n<p>Zo leer je programmeren. Je neemt een simpel voorbeeld, je speelt\ner wat mee en ontdekt nieuwe mogelijkheden.\nVoel je je al een beetje op je gemak ? Vast wel.</p>\n\n<h2>Okee,</h2>\n\n<p>laten we dan nu maar eens iets ongemakkelijks proberen zoals het omdraaien\nvan een nummer:</p>\n\n<pre><code>40.reverse\n</code></pre>\n","load_code":""},
"10":{"lang":"NL","title":"Doe niet zo gek","chapter":"N","answer":"^\\d{1,}$","ok":"Zie je, we kunnen alleen strings omdraaien","error":"","text":"<p>Een nummer kan je niet omdraaien. Misschien kan je een spiegel naast je monitor houden,\nmaar een nummer omdraaien kan echt niet.</p>\n\n<p>Ruby gaf daarom een foutmelding. Ruby wil je duidelijk maken dat er geen <strong>reverse methode</strong>\nbestaat voor nummers.</p>\n\n<p>Maar als je het nummer eerst eens om zou zetten naar een string:</p>\n\n<pre><code>40.to_s.reverse\n</code></pre>\n","load_code":""},
"11":{"lang":"NL","title":"Wat naar","chapter":"N","answer":"\\[\\]","ok":"Ja, dat is een mooie nieuwe, maar nog lege, lijst","error":"","text":"<p>Appels zijn anders dan peren. En nummers zijn anders dan strings.</p>\n\n<p>Alle Ruby objecten hebben methoden, maar sommige methoden werken alleen voor\nspecifieke objecten.\nJe kunt objecten van de ene soort meestal omzetten naar een andere soort.\nDaarvoor kent Ruby een aantal &ldquo;to&rdquo; methoden. In het Nederlands zouden we dat &ldquo;naar&rdquo;\nnoemen.</p>\n\n<ul>\n<li><strong>to_s</strong> verandert een object in een <strong>s</strong>tring</li>\n<li><strong>to_i</strong> verandert een object in een <strong>i</strong>nteger<br>\n(geheel getal)</li>\n<li><strong>to_a</strong> verandert een object in een <strong>a</strong>rray</li>\n</ul>\n\n<h3>Wat is array nu weer ?!</h3>\n\n<p>Dat is een soort lijst. Type maar deze (vierkante) teksthaakjes in: </p>\n\n<pre><code>[]\n</code></pre>\n","load_code":""},
"12":{"lang":"NL","title":"In de rij","chapter":"N","answer":"^\\[([-\\.\\d]+)(\\s*,\\s*[-\\d\\.]+){3,}\\]$","ok":"Bingo","error":"Probeer een vierde getal toe te voegen","text":"<p>In een lijst (<em>list</em> of <em>array</em> op z&#39;n Engels) kan je Ruby objecten opslaan.</p>\n\n<p>Net als een lijstje op papier, kent een Ruby lijst ook een bepaalde volgorde.</p>\n\n<blockquote>\n<p>Het is net als in de rij staan voor een frietkraam. Je staat achter iemand en\njij zou nooit proberen om voor te piepen. Toch ?<br>\nEn je houd goed in de gaten of die gast achter je niet voordringt.</p>\n</blockquote>\n\n<p>Ik heb hier een lijstje met 3 bingo getallen:</p>\n\n<pre><code>[12, 47, 35]\n</code></pre>\n\n<p>Probeer zelf een vierde getal toe te voegen aan de lijst.\nType een komma achter getal 35, daarna eventueel een spatie, gevolgd door een door\njou gekozen getal.</p>\n","load_code":""},
"13":{"lang":"NL","title":"Kan ik mijn hand al opsteken ?","chapter":"N","answer":"^47$","ok":"Okee","error":"","text":"<p>Ok, we hebben een lijst met bingo getallen. Wat is hoogste getal ?</p>\n\n<p>Probeer: </p>\n\n<pre><code>[12, 47, 35].max\n</code></pre>\n","load_code":""},
"14":{"lang":"NL","title":"Wie wat bewaart voor later","chapter":"N","answer":"^\\[(\\d+)(,\\s*\\d+){2,}\\]$","ok":"Bewaard!","error":"","text":"<p>Ok we hebben een lijst. Maar het is best wel irritant om die lijst iedere keer\nin te moeten typen als we &lsquo;em nodig hebben.</p>\n\n<p>We kunnen de lijst met bingo getallen bewaren op een kaart:</p>\n\n<pre><code>kaart = [12, 47, 35]\n</code></pre>\n","load_code":""},
"15":{"lang":"NL","title":"Tiep kaart","chapter":"N","answer":"\\[(\\d+(, )?){2,}\\]","ok":"Opgehaald!","error":"","text":"<p>En als je nu eens kaart intypt:</p>\n\n<pre><code>kaart\n</code></pre>\n","load_code":"kaart = [12, 47, 35]"},
"16":{"lang":"NL","title":"Opgeslagen","chapter":"N","answer":"\\[12, 35, 47\\]","ok":"Dat is een gesorteerde lijst","error":"","text":"<p>We kunnen dus ons lijstje met bingo getallen bewaren door deze in een <strong>variabele</strong>\nte stoppen. Een variabele met de naam <em>kaart</em>. Maar als je een andere naam had willen\ngebruiken, <em>jantjeslijst</em> of zo, was dat ook prima geweest.</p>\n\n<p>Als je je wat langer verdiept in programmeren zal je zien dat het werken met variablen\nÃ©Ã©n van de belangrijkste dingen is.</p>\n\n<p>Zullen we onze bingo getallen nu eens op volgorde zetten?</p>\n\n<pre><code>kaart.sort!\n</code></pre>\n\n<p>We hadden dus een lijst. Die lijst is nu gesorteerd van klein naar groot.\nDe waarde van de variable kaart is nu veranderd.  </p>\n\n<blockquote>\n<p>Zag je dat uitroepteken achter de <em>sort!</em> methode?<br>\nRuby methodes hebben vaak zo&#39;n uitroepteken. Dat betekent:\n&ldquo;<em>Hee jij daar opletten, ik ga de waarde van de variabele veranderen</em>&rdquo;.</p>\n</blockquote>\n","load_code":"kaart = [12, 47, 35]"},
"17":{"lang":"NL","title":"Elementair","chapter":"N","answer":"^(12|35|47)$","ok":"Ok","error":"Bijna","text":"<p>We hebben ons lijstje met bingo getallen in variabele kaart staan. Hoe krijgen we\nde getallen er weer Ã©Ã©n voor Ã©Ã©n uit?</p>\n\n<p>We hebben <strong>max</strong> al gebruikt om het hoogste getal te bepalen. Je kunt ook <strong>first</strong>\nof <strong>last</strong> gebruiken voor het eerste en laatste element van de lijst.\nMaar hoe haal je er Ã©Ã©n specifiek element uit?</p>\n\n<h3>[ ]</h3>\n\n<p>Ruby gebruikt hiervoor de vierkant teksthaken.\nDeze worden trouwens heel vaak gebruikt in Ruby.</p>\n\n<p>Ok, we halen de bingo getallen Ã©Ã©n voor Ã©Ã©n op:</p>\n\n<pre><code>puts kaart[0]\nputs kaart[1]\nputs kaart[2]\n</code></pre>\n\n<p>Maar waarom [0], [1], [2] ? En niet [1], [2] and [3] ?</p>\n\n<p>Heeft dat met dat Japanse Zen gedoe te maken?<br>\nNee hoor, computer programmeurs beginnen nou eenmaal graag met tellen vanaf\nnul. En niet alleen Ruby programmeurs maar alle programmeurs. Het heeft\nzelfs een naam: <em>zero based indexing</em>.</p>\n\n<blockquote>\n<p>Tip: mocht je het vergeten zijn, je kunt de <strong>Copy</strong> knop gebruiken om de\nvoorbeeldcode over te nemen in de editor.</p>\n</blockquote>\n","load_code":"kaart = [12, 47, 35]"},
"18":{"lang":"NL","title":"We zijn bij samenvatting 2","chapter":"Y","answer":"\\w+","ok":"Rijmt het ?","error":"","text":"<p>Kijk eens wat we in het tweede deel hebben geleerd:</p>\n\n<h3>Foutmeldingen</h3>\n\n<p>Probeer je een nummer om te draaien of doe je iets anders verdachts, dan vertelt\nRuby dat met een foutmelding.</p>\n\n<h3>Array&rsquo;s</h3>\n\n<p>Een array is een lijst om dingen in een bepaalde volgorde in op te slaan.</p>\n\n<h3>Variabelen</h3>\n\n<p>In een variabele kan je dingen bewaren. En je kunt een variable een naam geven.\nMet het = teken geef je een waarde aan een variabele. Bijvoorbeeld:<br>\nkaart = [14, 37, 18].</p>\n\n<h3>2/8</h3>\n\n<p>Deze cursus bevat acht delen. Je bent dus al op een kwart!\nEigenlijk best wel simpel allemaal. Er komen nog veel leuke dingen langs.</p>\n\n<h2>Maar,</h2>\n\n<p>nu eerst even wat anders. Hou je een beetje van poÃ«zie? Ik heb een versje\ngemaakt en in een variabele gestopt. Kijk maar:</p>\n\n<pre><code>puts vers\n</code></pre>\n","load_code":"vers = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nBut when I saw it on television,\\nPlanting our flag on Halley's comet,\\nMore still did I want to eat it.\\n\""},
"19":{"lang":"NL","title":"Helaas, je houd niet van toast","chapter":"N","answer":"(toast){0}","ok":"Heerlijk","error":"","text":"<p>Ik snap het helemaal als je niet van versjes over toast houdt. Ik zou zeggen pas het maar\naan. Leef je uit. Verander de toast maar in een boterham of zo. Begin zo:</p>\n\n<pre><code>vers.gsub(&quot;toast&quot;, &quot;stroopwafel&quot;)\n</code></pre>\n\n<p>De <strong>gsub</strong> methode staat voor: <em>global substitute</em>. Daarmee vervang je iedere\n&ldquo;toast&rdquo; door &ldquo;stroopwafel&rdquo;.</p>\n\n<blockquote>\n<p>Voetnoot van de vertaler: ik vond de Engelse versie van het gedicht te leuk en te\nlastig om te vertalen. Heb het dus maar zo gelaten.<br>\nJe zult al wel gemerkt hebben dat veel dingen helemaal niet te vertalen zijn.\nZoals de taal Ruby zelf.<br>\nIn de praktijk is Engels de voertaal voor programmeurs. Wen er maar vast aan.</p>\n</blockquote>\n","load_code":"prev"},
"20":{"lang":"NL","title":"Ready, Aim","chapter":"N","answer":"^\\n.ti tae ot (.+)","ok":"Lijkt wel Latijn","error":"","text":"<p>Even een vraagje: wat gebeurt er als we het hele gedicht omdraaien?</p>\n\n<pre><code>vers.reverse\n</code></pre>\n","load_code":"prev"},
"21":{"lang":"NL","title":"Te veel van het goede","chapter":"N","answer":"^\\[\"More still did (.+)","ok":"Ja, we zijn er bijna","error":"","text":"<p>We hebben het hele vers omgedraaid, letter voor letter.\nIk wilde eigenlijk alleen maar de volgorde van de regels omdraaien.</p>\n\n<p>Dus de regels achterstevoren. Niet de letters, dat zou achterlijk zijn.</p>\n\n<p>Zoiets:</p>\n\n<pre><code>vers.lines.reverse\n</code></pre>\n","load_code":"prev"},
"22":{"lang":"NL","title":"De schakels van de ketting","chapter":"N","answer":"^More still did (.+)","ok":"Goed gedaan hoor!<br/>De join methode heeft dat array weer aan elkaar geplakt.","error":"","text":"<p>Wat gebeurde daar ? Je voerde <strong>vers.lines.reverse</strong> uit en toen?</p>\n\n<p>Twee dingen. Eerst zette je het versje om in losse regels met de <em>lines</em>\nmethode. <em>Lines</em> (regels in het Nederlands) zet een string om naar een array.\nIedere regel wordt Ã©Ã©n element in het array.</p>\n\n<p>Vervolgens heb je het array omgedraaid. Regel voor regel.</p>\n\n<p>We voegen nog Ã©Ã©n methode toe aan het einde:</p>\n\n<pre><code>puts vers.lines.reverse.join\n</code></pre>\n\n<blockquote>\n<p>Als we meerdere methodes op deze manier aan elkaar koppelen, als een soort\nketting van methoden, noemen we dit in het Engels: <strong>method chaining</strong>.</p>\n</blockquote>\n","load_code":"prev"},
"23":{"lang":"NL","title":"O nee, samenvatting 3","chapter":"Y","answer":"\\{\\}","ok":"Je hebt een haspel gemaakt !","error":"","text":"<h3>Uitroeptekens</h3>\n\n<p>Methodes kunnen gevolgd worden door een uitroepteken (soms ook een vraagteken).\nDeze zijn er alleen maar om goed duidelijk te maken wat de functie is van de\nmethode. Dat is alles.</p>\n\n<h3>String manipulatie</h3>\n\n<p>Wijzigen van strings.</p>\n\n<h3>Chaining</h3>\n\n<p>Door methoden aaneen te rijgen, als de schakels van een ketting, kan je heel veel\ndoen met heel weinig code. Een versje splitsen, omdraaien en weer in elkaar zetten:<br>\nvers.lines.reverse.join</p>\n\n<p>Misschien vind je het leuk om nog wat meer met het gedicht to spelen. Bijvoorbeeld met\n<em>vers.downcase</em> of <em>vers.swapcase</em>. De complete lijst met string methoden is\n<a href=\"http://ruby-doc.org/core/classes/String.html\" target=\"_blank\">hier</a>\nte vinden.</p>\n\n<h2>Klaar ?</h2>\n\n<p>Als je door wilt gaan typ dan:</p>\n\n<pre><code>boeken = {}\n</code></pre>\n","load_code":"prev"},
"24":{"lang":"NL","title":"Een boekenlijst","chapter":"N","answer":"^(uitstekend|best_goed|matig|best_wel_slecht|vreselijk)$","ok":"Dank je voor je boekverslag","error":"Gebruik: uitstekend, best_goed, matig, best_wel_slecht of vreselijk.<br/>Vergeet de dubbele punt niet","text":"<p>Je hebt net een lege haspel gemaakt. Een wat ?</p>\n\n<p>In het Engels heet dit een <strong>hash</strong>. En ik stel voor dat we dat woord voortaan gebruiken.\nHash betekent zoiets als verhaspelen, het bij elkaar en door elkaar gooien van de letters\nvan een woord zodat het korter wordt. Het heeft te maken met de manier waarop Ruby\neen hash opslaat in het geheugen van de computer. Is verder niet belangrijk om te weten.</p>\n\n<blockquote>\n<p>Wel belangrijk om te weten is dat een hash hetzelfde is als een array, alleen\nheeft ieder element van de hash een naam. Een array element heeft alleen een nummer.</p>\n</blockquote>\n\n<p>We gaan onze hash gebruiken om er wat boekverslagen in op te slaan. Dit zijn de waarderingen:</p>\n\n<ul>\n<li>:uitstekend &rarr; een meesterwerk</li>\n<li>:best_goed &rarr; amusant</li>\n<li>:matig &rarr; goed en slecht tegelijk</li>\n<li>:best_wel_slecht &rarr; vooral slecht</li>\n<li>:vreselijk &rarr; hopeloos geval</li>\n</ul>\n\n<p>Om een boekverslag toe te voegen zetten we de titel van het boek tusen [ ] haakjes en\nomdat de titel een string is ook tussen aanhalingstekens. Bijvoorbeeld:</p>\n\n<pre><code>boeken[&quot;De regenboog&quot;] = :uitstekend\n</code></pre>\n\n<blockquote>\n<p>Het is misschien wel handig om te weten dat alle TryRuby lessen los van elkaar\nstaan. Dus als je hier tig boekverslagen intypt kan je die alleen in deze les gebruiken.\nJe kan ze natuurlijk wel kopieÃ«ren en plakken in de volgende les.<br>\nIk heb iedere les voldoende dingen meegegeven waar je mee kunt spelen.</p>\n</blockquote>\n","load_code":"boeken = {}"},
"25":{"lang":"NL","title":"Meer reviews","chapter":"N","answer":"[3-9]","ok":"De length methode werkt zowel voor een string, array als hash","error":"","text":"<p>Ok, ga maar door met toevoegen van boekverslagen. Als je de hele lijst wilt zien\nkan je <strong>puts boeken</strong> gebruiken.</p>\n\n<p>De beoordelingen zijn: :uitstekend, :best_goed, :matig, :best_wel_slecht, :vreselijk.</p>\n\n<blockquote>\n<p>De hier getoonde beoordelingen zijn geen strings. Als je een dubbele punt voor een woord\nzet krijg je een <strong>symbool</strong>.  </p>\n</blockquote>\n\n<p>Symbolen kosten de computer minder geheugenruimte. Maar belangrijker:\nals je een symbool in een programma ziet staan geeft dat aan dat dat symbool een bepaalde\nbetekenis heeft en niet zomaar een willekeurig gekozen woord is.</p>\n\n<p>Voeg nog 2 boekverslagen toe. Gebruik <strong>boeken.length</strong> om te zien hoeveel verslagen\ner al in de hash zitten:</p>\n\n<pre><code>boeken[&quot;Het puffertje&quot;] = :vreselijk\nboeken[&quot;Kleurenblind&quot;] = :matig\n\nputs boeken\n\nputs boeken.length\n</code></pre>\n","load_code":"boeken = {\"De regenboog\" => :uitstekend}"},
"26":{"lang":"NL","title":"Eh, wat vond ik ook al weer van De regenboog?","chapter":"N","answer":"^(uitstekend|quite_good|mediocre|quite_not_good|abysmal)$","ok":"O ja, ik vond het een meesterwerk","error":"","text":"<p>Weet je nog hoe we een waarde uit een array haalden:<br>\n<strong>puts ticket[1]</strong>.</p>\n\n<p>Bij een hash werkt dit hetzelfde, alleen gebruiken we geen nummer om een element op te zoeken\nmaar een naam.</p>\n\n<p>Dus als je een oud boekverslag op wilt zoeken zet je nu de naam van het boek tussen de [ ]\nhaken. En het = teken laten we weg:</p>\n\n<pre><code>boeken[&quot;De regenboog&quot;]\n</code></pre>\n","load_code":"boeken = {\"De regenboog\" => :uitstekend, \"Het puffertje\" => :vreselijk, \"Kleurenblind\" => :matig}"},
"27":{"lang":"NL","title":"De hash als paar","chapter":"N","answer":"^\\[\".*\"\\]","ok":"Je hebt de sleutels gevonden","error":"","text":"<p>In tegenstelling tot een array kent een hash geen volgorde van zijn elementen. Daar\nis een hash ook niet voor gemaakt.</p>\n\n<p>Een hash bevat alleen maar paren. Ieder paar bestaat uit een <strong>sleutel</strong> en een\n<strong>waarde</strong> (<em>key</em> en <em>value</em> in het Engels).</p>\n\n<p>In jouw boekverslagen is de titel van het boek de sleutel en de beoordeling is de waarde.</p>\n\n<p>Als je alle boektitels wilt zien kan je alle hash sleutels opvragen:</p>\n\n<pre><code>boeken.keys\n</code></pre>\n\n<p>Probeer dit ook eens met .values in plaats van .keys.</p>\n","load_code":"prev"},
"28":{"lang":"NL","title":"Hoe streng ben jij?","chapter":"N","answer":"\"matig\"","ok":"Wow! Je hebt een scorelijst gemaakt.","error":"","text":"<p>Misschien geef jij wel gemene boek beoordelingen ? We gaan de score eens bijhouden.\nDat doen we in een nieuwe hash <strong>scores</strong>:</p>\n\n<p>Ik heb wat code geschreven om de beoordelingen te tellen. Geen paniek als je de code\nniet meteen begrijpt. In de volgende lessen wordt het allemaal uitgelegd.</p>\n\n<p>Typ:</p>\n\n<pre><code>scores = Hash.new {0}\n\nboeken.values.each { |beoordeling|\n  scores[beoordeling] += 1\n}\n\nputs scores\n</code></pre>\n\n<p>Dat verticale streepje | zit op de meeste toetsenborden boven de enter toets.</p>\n\n<p>Die regel met <em>+= 1</em> betekent: verhoog de waarde met 1.</p>\n","load_code":"boeken = {\"De regenboog\" => :uitstekend, \"Het puffertje\" => :vreselijk, \"Kleurenblind\" => :matig, \"Bloemetjes en bijtjes\" => :matig}"},
"29":{"lang":"NL","title":"Een blokje om","chapter":"N","answer":"\\w+","ok":"Yodelay!","error":"","text":"<p>We hebben net een mooie en handige eigenschap van Ruby gebruikt, namelijk een <strong>blok</strong>.\nDaar gaan we in deze en de volgende les eens beter naar kijken.</p>\n\n<p>Heel simpel gezegd is een blok gewoon een stukje Ruby code dat tussen accolades { } staat.</p>\n\n<p>Hier heb ik nog een blok voor je:</p>\n\n<pre><code>5.times { print &quot;Odelay! &quot; }\n</code></pre>\n\n<p>Een blok zit altijd vast aan een methode. In dit voorbeeld de <strong>times</strong> methode.<br>\nTimes (keer) voert een blok meerdere keren uit. In dit geval 5 keer.</p>\n","load_code":""},
"30":{"lang":"NL","title":"Ben je bij de tijd?","chapter":"N","answer":"^[0-9]$","ok":"Goed getimed!","error":"Voer het blok 0 tot 9 keer uit.","text":"<p>In het eerste voorbeeld van een blok (bij het maken van de scorelijst) zagen we al dat\nwe een waarde kunnen doorgeven aan het blok.\nWelke waarden worden <strong>doorgegeven</strong> wordt bepaald door de methode die het blok uitvoert.</p>\n\n<p>De waarden die worden <strong>ontvangen</strong> door het blok, worden in de variabele gezet die\naan het begin van het blok tussen 2 verticale streepjes | staat.</p>\n\n<p>We kunnen dit uitproberen met het volgende blok:</p>\n\n<pre><code>5.times { |tijd|\n  puts tijd\n}\n</code></pre>\n\n<p>Methode <strong>.times</strong> geeft een waarde door aan variabele <strong>|tijd|</strong>.<br>\nDe <em>tijd</em> variabele is alleen maar binnen het blok bekend !</p>\n\n<blockquote>\n<p>Zie je dat je code over meerdere regels uit kunt splitsen? Dit maakt code\nmakkelijker te lezen.</p>\n</blockquote>\n","load_code":""},
"31":{"lang":"NL","title":"Samenvatting 4 is hier","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Deel 3 duurde wat langer om door te nemen. Je hebt dit allemaal geleerd:</p>\n\n<h3>Hash</h3>\n\n<p>Een soort woordenboek met sleutels en waarden, die je maakt met: <strong>{}</strong></p>\n\n<h3>Symbolen</h3>\n\n<p>Korte, duidelijke, efficiente woorden, die beginnen met een dubbele punt: <strong>:uitstekend</strong></p>\n\n<h3>Blokken</h3>\n\n<p>Stukjes code die je aan allerlei Ruby methoden kunt hangen. Hiermee maakte je een\nscorelijst:<br>\n<strong>boeken.values.each { |beoordeling|<br>\n&nbsp;&nbsp;scores[beoordeling] += 1<br>\n}</strong></p>\n\n<h3>En nu</h3>\n\n<p>In de volgende lessen gaan we ons verder verdiepen in methoden.</p>\n","load_code":""},
"32":{"lang":"NL","title":"To (be) or not to (be)","chapter":"N","answer":"Hello","ok":"Hoi","error":"","text":"<p>Er is iets waar we het nog niet over hebben gehad: parameters voor methoden.\nIn het Engels vaak ook &ldquo;arguments&rdquo; genoemd.</p>\n\n<p>Toen we het gedicht een beetje veranderden gebruikten we:\n<strong>vers.gsub(&ldquo;toast&rdquo;, &ldquo;stroopwafel&rdquo;)</strong></p>\n\n<p>De gsub methode heeft 2 parameters nodig. Deze gaven we door met de twee strings tussen haakjes\nachter de methode.\n<em>Parameters zorgen er voor dat een methode precies weet wat &lsquo;ie moet doen.</em></p>\n\n<h3>Haakjes</h3>\n\n<p>Meestal maakt het Ruby niets uit of je de haakjes wel of niet gebuikt. Dit zou ook werken:<br>\n<strong>vers.gsub &ldquo;toast&rdquo;, &ldquo;stroopwafel&rdquo;</strong></p>\n\n<p>We hebben al een andere methode gebruikt met een parameter. Heel vaak zelfs, maar het viel niet\necht op:</p>\n\n<pre><code>puts &quot;Hello&quot;\nputs(&quot;Hello&quot;)\n</code></pre>\n\n<p>Ja, <strong>puts</strong> is ook een methode. Puts met of zonder haakjes voor de parameter maakt voor Ruby\nniets uit. De versie zonder is wel iets makkelijker te lezen.\nEn het scheelt jou natuurlijk een hoop kostbare toetsaanslagen!</p>\n\n<blockquote>\n<p>Ik denk dat de conclusie hier is dat met haakjes alles mag, als het maar goed leesbaar is.</p>\n</blockquote>\n\n<h3>to (be) or not to (be)</h3>\n\n<p>Dus als <em>to</em> een methode is, en <em>be</em> een parameter dan weten wij het antwoord nu wel op deze\neeuwenoude vraag. Het is gewoon een kwestie van voorkeur voor <em>to be</em> of voor <em>to(be)</em></p>\n\n<p>Wil je meer weten van Shakespeare ? Klik op <em>Next</em>.</p>\n","load_code":"vers = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nEnz. enz. enz.\\n\""},
"33":{"lang":"NL","title":"The Taming of the Shrew","chapter":"N","answer":"^tem","ok":"Goed goed !","error":"","text":"<p>Je hebt Ruby inmiddels al aardig onder de knie. De basis in ieder geval.\nHet enige wat je nog moet doen is het leren kennen van meer methoden en\ngrotere blokken code uitproberen.</p>\n\n<p>ÃÃ©n ding wat ik je nog uit moet leggen is het zelf maken van methoden.\n<strong>Ahum!</strong> Geen getreuzel meer, we beginnen:</p>\n\n<p>Behalve de in Ruby ingebakken methoden (zoals puts, sort, times) kan je ook\nzelf methoden definiÃ«ren. Maar waarom zou je dat eigenlijk willen. Twee redenen:</p>\n\n<h3>Om je programma korter te maken</h3>\n\n<p>Als je dezelfde functionaliteit nodig hebt op meer dan Ã©Ã©n plek in je code,\nkan je die functionaliteit beter in een methode stoppen. De code wordt hierdoor\nkorter.</p>\n\n<h3>Beter leesbare code</h3>\n\n<p>Stel je voor dat je code heel veel verschillende dingen moet doen. Je <strong>zou</strong>\nal die code als Ã©Ã©n lang stuk kunnen intypen. Maar de code zou hierdoor moeilijk\nte lezen en te begrijpen zijn. Vooral als je het een tijd later weer bekijkt.</p>\n\n<p>Het is beter om die lange code over meerdere methoden te verdelen. Geef iedere\nmethode een begrijpelijk naam. Je zal jezelf later dankbaar zijn.</p>\n\n<p>Hoe definieer je een methode ? Zo:</p>\n\n<pre><code>def tem( aantal_heksen )\nend\n</code></pre>\n\n<p>P.S. &ldquo;The Taming of the Shrew&rdquo; (Het temmen van de heks) is een toneelstuk van Shakespeare.</p>\n","load_code":""},
"34":{"lang":"NL","title":"In Ruby betekent Def Leppard definieer methode Leppard","chapter":"N","answer":"^tem","ok":"Tem is niet tam","error":"","text":"<p>Goed zo, je hebt zelf een methode gemaakt. Je begon met <strong>def</strong> (afkorting van definieer)\ngevolgd door de naam van de nieuwe methode.<br>\nVervolgens gaf je op dat de methode Ã©Ã©n parameter heeft.\nJe beÃ«indigde de definitie met het woordje <strong>end</strong>.</p>\n\n<p>Nu hoeven alleen nog maar wat code aan de nieuwe methode toe te voegen.</p>\n\n<p>Deze code:</p>\n\n<pre><code>def tem( aantal_heksen )\n  aantal_heksen.times {\n    puts &quot;Een heks is getemd&quot;\n  }\nend\n</code></pre>\n\n<blockquote>\n<p><strong>P.S.</strong><br>\nAls je de titel van deze les niet begrijpt snap ik dat wel.\n<a href=\"http://nl.wikipedia.org/wiki/Def_Leppard\" target=\"_blank\">Def Leppard</a>\nis de naam van een, ooit beroemde, Engelse rock band.</p>\n</blockquote>\n","load_code":""},
"35":{"lang":"NL","title":"De zoete vruchten van je eigen creatie","chapter":"N","answer":"^Een heks is getemd","ok":"Dat zal ze leren","error":"","text":"<p>En zo worden nieuwe methodes geboren.</p>\n\n<p>Ik wil &lsquo;em meteen gebruiken:</p>\n\n<pre><code>tem 5\n</code></pre>\n","load_code":"def tem( aantal_heksen );aantal_heksen.times{puts \"Een heks is getemd\"};end;"},
"36":{"lang":"NL","title":"Geven en nemen","chapter":"N","answer":"\\d+","ok":"Ja. Super.","error":"","text":"<p>De meeste methoden willen niet alleen Ã©Ã©n of meer parameters als invoer, maar <strong>geven ook\nweer iets terug</strong>. Ik heb onze methode een beetje aangepast zodat we een waarde terug krijgen.\nRuby gebruikt hiervoor het woordje <strong>return</strong>.</p>\n\n<p>Probeer maar:</p>\n\n<pre><code>def tem( aantal_heksen )\n  aantal_heksen.times {\n    puts &quot;Een heks is getemd&quot;\n  }\n  return aantal_heksen\nend\n\nputs tem(3)\n</code></pre>\n\n<h3>Return</h3>\n\n<p>En omdat je zo leergierig bent heb ik nog een extra tip voor je:\nje mag in Ruby het woordje <strong>return</strong> weglaten. Ruby geeft automatisch de laatste\nwaarde waar in de methode iets mee gedaan is terug.</p>\n\n<p>De laatste regel van de methode kunnen we veranderen in: <strong>aantal_heksen</strong>.\nProbeer maar.</p>\n\n<p>Maar. Methode <strong>.times</strong> geeft ook al <em>aantal_heksen</em> terug. Dus we kunnen die hele\nlaatste regel weglaten.<br>\nEigenlijk deed de oorspronkelijke versie van de methode al precies wat we wilden!</p>\n","load_code":""},
"37":{"lang":"NL","title":"Ben je er nog? Samenvatting 5 groet u","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Goed gedaan! Echt. Serieus. Ik meen het.</p>\n\n<p>Dit heb je in de afgelopen minuten geleerd:</p>\n\n<h3>Methoden</h3>\n\n<p>Methoden kan je definiÃ«ren met <strong>def</strong> en een naam. Methodes zorgen ervoor dat je\nprogramma&rsquo;s korter en beter leesbaar zijn.</p>\n\n<h3>Parameters</h3>\n\n<p>Methodes kunnen parameters hebben.</p>\n\n<h3>Return waarde</h3>\n\n<p>Methodes geven (bijna) altijd een waarde terug.</p>\n\n<h2>En verder</h2>\n\n<p>To be or not to (be) weten we nu het antwoord wel op.<br>\nNog maar 3 delen te gaan.<br>\nInteresse in meer Shakespeare?</p>\n","load_code":""},
"38":{"lang":"NL","title":"We kunnen de hele wereld aan","chapter":"N","answer":"^\\{\\\"William","ok":"Goed. Wel lastig te lezen zo.","error":"","text":"<p>Tot op heden hebben we programma&rsquo;s uitgevoerd die we zelf hebben ingetypt. En dat is\nharstikke leuk. Vooral dat <em>Odelayen</em> vond ik een hoogtepunt.\nMaar dit is wel het internet tijdperk. Het wordt dus tijd om de rest van de wereld\nbij ons programmeerwerk te betrekken!</p>\n\n<p>Er zijn heel veel websites beschikbaar die je om informatie kunt vragen. Deze link geeft\nje bijvoorbeeld al het\n<a href=\"http://news.google.nl/news/section?q=ruby&output=rss\" target=\"_blank\">actuele nieuws</a>\nover Ruby.</p>\n\n<p>Jouw web browser toont dit waarschijnlijk in een goed leesbaar formaat. Maar kijk eens naar\nde broncode van die webpagina (met control-U). Dan zie een lange regel met vreemd opgemaakte\ntekst. In het Google news voorbeeld is dit het <strong>rss</strong> formaat.</p>\n\n<h3>Formaten</h3>\n\n<p>Er zijn heel veel verschillende formaten in gebruik op het grote internet. Met\nrare namen als: html, xml en json. Ook deze website gebruikt dit soort formaten.</p>\n\n<p>Ik ben zo vrij geweest een methode voor te bereiden waarmee je de volledige lijst\nmet toneelstukken van William Shakespeare van het internet haalt.\n(Stiekum komt deze lijst van de server waar deze website op draait, we vallen dus\nniemand lastig.)</p>\n\n<p>Haal de gegevens op met:</p>\n\n<pre><code>get_shakey\n</code></pre>\n","load_code":"def get_shakey;JSON.parse(\"{\\\"William Shakespeare\\\": {\\\"1\\\": {\\\"title\\\": \\\"The Two Gentlemen of Verona\\\", \\\"finished\\\": 1591},\\\"2\\\": {\\\"title\\\": \\\"The Taming of the Shrew\\\", \\\"finished\\\": 1591},\\\"3\\\": {\\\"title\\\": \\\"Henry VI, Part 2\\\", \\\"finished\\\": 1591},\\\"4\\\": {\\\"title\\\": \\\"Henry VI, Part 3\\\", \\\"finished\\\": 1591},\\\"5\\\": {\\\"title\\\": \\\"Henry VI, Part 1\\\", \\\"finished\\\": 1592},\\\"6\\\": {\\\"title\\\": \\\"Titus Andronicus\\\", \\\"finished\\\": 1592},\\\"7\\\": {\\\"title\\\": \\\"Richard III\\\", \\\"finished\\\": 1593},\\\"8\\\": {\\\"title\\\": \\\"Edward III\\\", \\\"finished\\\": 1593},\\\"9\\\": {\\\"title\\\": \\\"The Comedy of Errors\\\", \\\"finished\\\": 1594},\\\"10\\\": {\\\"title\\\": \\\"Love's Labour's Lost\\\", \\\"finished\\\": 1595},\\\"11\\\": {\\\"title\\\": \\\"Love's Labour's Won\\\", \\\"finished\\\": 1596},\\\"12\\\": {\\\"title\\\": \\\"Richard II\\\", \\\"finished\\\": 1595},\\\"13\\\": {\\\"title\\\": \\\"Romeo and Juliet\\\", \\\"finished\\\": 1595},\\\"14\\\": {\\\"title\\\": \\\"A Midsummer Night's Dream\\\", \\\"finished\\\": 1595},\\\"15\\\": {\\\"title\\\": \\\"King John\\\", \\\"finished\\\": 1596},\\\"16\\\": {\\\"title\\\": \\\"The Merchant of Venice\\\", \\\"finished\\\": 1597},\\\"17\\\": {\\\"title\\\": \\\"Henry IV, Part 1\\\", \\\"finished\\\": 1597},\\\"18\\\": {\\\"title\\\": \\\"The Merry Wives of Windsor\\\", \\\"finished\\\": 1597},\\\"19\\\": {\\\"title\\\": \\\"Henry IV, Part 2\\\", \\\"finished\\\": 1598},\\\"20\\\": {\\\"title\\\": \\\"Much Ado About Nothing\\\", \\\"finished\\\": 1599},\\\"21\\\": {\\\"title\\\": \\\"Henry V\\\", \\\"finished\\\": 1599},\\\"22\\\": {\\\"title\\\": \\\"Julius Caesar\\\", \\\"finished\\\": 1599},\\\"23\\\": {\\\"title\\\": \\\"As You Like It\\\", \\\"finished\\\": 1600},\\\"24\\\": {\\\"title\\\": \\\"Hamlet\\\", \\\"finished\\\": 1601},\\\"25\\\": {\\\"title\\\": \\\"Twelfth Night\\\", \\\"finished\\\": 1601},\\\"26\\\": {\\\"title\\\": \\\"Troilus and Cressida\\\", \\\"finished\\\": 1602},\\\"27\\\": {\\\"title\\\": \\\"Sir Thomas More\\\", \\\"finished\\\": 1604},\\\"28\\\": {\\\"title\\\": \\\"Measure for Measure\\\", \\\"finished\\\": 1604},\\\"29\\\": {\\\"title\\\": \\\"Othello\\\", \\\"finished\\\": 1604},\\\"30\\\": {\\\"title\\\": \\\"All's Well That Ends Well\\\", \\\"finished\\\": 1605},\\\"31\\\": {\\\"title\\\": \\\"King Lear\\\", \\\"finished\\\": 1606},\\\"32\\\": {\\\"title\\\": \\\"Timon of Athens\\\", \\\"finished\\\": 1606},\\\"33\\\": {\\\"title\\\": \\\"Macbeth\\\", \\\"finished\\\": 1606},\\\"34\\\": {\\\"title\\\": \\\"Antony and Cleopatra\\\", \\\"finished\\\": 1606},\\\"35\\\": {\\\"title\\\": \\\"Pericles, Prince of Tyre\\\", \\\"finished\\\": 1608},\\\"36\\\": {\\\"title\\\": \\\"Coriolanus\\\", \\\"finished\\\": 1608},\\\"37\\\": {\\\"title\\\": \\\"The Winter's Tale\\\", \\\"finished\\\": 1611},\\\"38\\\": {\\\"title\\\": \\\"Cymbeline\\\", \\\"finished\\\": 1610},\\\"39\\\": {\\\"title\\\": \\\"The Tempest\\\", \\\"finished\\\": 1611},\\\"40\\\": {\\\"title\\\": \\\"Cardenio\\\", \\\"finished\\\": 1613},\\\"41\\\": {\\\"title\\\": \\\"Henry VIII\\\", \\\"finished\\\": 1613},\\\"42\\\": {\\\"title\\\": \\\"The Two Noble Kinsmen\\\", \\\"finished\\\": 1614}}}\");end;"},
"39":{"lang":"NL","title":"The Two Noble Kinsmen","chapter":"N","answer":"^The Two Noble Kinsmen$","ok":"Dat is beter!","error":"","text":"<p>Okee, we hebben nu een lijst met toneelstukken. Deze lijst was in het json formaat.\nGelukkig kent Ruby een methode om json om te zetten naar een hash.\nDe <em>get_shakey</em> methode heeft dat al voor ons gedaan.</p>\n\n<p>Helaas is de structuur van het json bestand wel overgenomen in de hash. Nog steeds vrij\nlastig te lezen dus. Als we nou eens een methode maken die alles netjes uitprint.</p>\n\n<p>Kijk nog eens naar de lijst van de vorige les. Ziet er ongeveer zo uit:</p>\n\n<ul>\n  <li>&ldquo;William Shakespeare&rdquo;\n  <ul>\n      <li>&ldquo;1&rdquo;\n      <ul>\n        <li>&ldquo;title&rdquo;: &ldquo;The Two Gentlemen of Verona&rdquo;</li>\n        <li>&ldquo;finished&rdquo;: 1591</li>\n      </ul>\n      </li>\n      <li>&ldquo;2&rdquo;\n      <ul>\n        <li>&ldquo;title&rdquo;: &ldquo;The Taming of the Shrew&rdquo;</li>\n        <li>&ldquo;finished&rdquo;: 1591</li>\n      </ul>\n      </li>\n      <li>&hellip;</li>\n  </ul>\n  </li>\n</ul>\n\n<p>Om alle toneelstukken te zien moeten we eerst het &ldquo;William Shakespeare&rdquo; hash element\nbenaderen. Daarna moeten we door alle elementen daaronder bladeren. <strong>Itereren</strong>\nheet dat.<br>\nRuby heeft hier een methode voor: <strong>each</strong>. We zijn &lsquo;em al even tegengekomen bij\nhet maken van de boeken scores.</p>\n\n<p>We gaan alles wat methode <strong>each</strong> vindt doorgeven aan een blok:</p>\n\n<pre><code>s = get_shakey\n\ns[&quot;William Shakespeare&quot;].each { |key, val|\n  puts val[&quot;title&quot;]\n}\n</code></pre>\n","load_code":"prev"},
"40":{"lang":"NL","title":"En nu in Ã©Ã©n keer","chapter":"N","answer":"^4$","ok":"Idd, Shakespeare schreef 4 toneelstukken in 1591. Druk baasje.","error":"Nee, in 1591 schreef hij er 4","text":"<p>Okee, maar stel dat we alleen geÃ¯nteresseerd zijn in de namen en het aantal toneelstukken\ndat door Shakespeare in Ã©Ã©n jaar is geschreven?</p>\n\n<p>Met <strong>select</strong> kunnen we waarden selecteren uit een hash. De <em>select</em> methode gebruikt een\nblok om aan te geven wat we precies willen selecteren.<br>\nWe kunnen de door <em>select</em> teruggegeven waarden gebruiken in de <strong>each</strong> methode. Dit hebben\nwe al eerder gezien en is weer een voorbeeld van <em>method chaining</em>.</p>\n\n<blockquote>\n<p>Ik heb een <strong>tel_toneelstukken</strong> methode voor je gemaakt.\nProbeer jij eens uit te zoeken hoeveel toneelstukken Shakespeare in <strong>1591</strong> heeft geschreven:</p>\n</blockquote>\n\n<pre><code>def tel_toneelstukken(jaar)\n  s = get_shakey\n\n  s[&quot;William Shakespeare&quot;]\n    .select { |k, v|\n      v[&quot;finished&quot;] == jaar\n    }.each { |key, val|\n      puts val[&quot;title&quot;]\n    }.count\nend\n\nputs tel_toneelstukken(0)\n</code></pre>\n\n<p>Viel het je op dat ik <em>count</em> aan de <em>each</em> methode heb vastgeplakt.\nDit zorgt voor de return waarde van de <strong>tel_toneelstukken</strong> methode.</p>\n\n<p>Er is nog een mogelijkheid voor <em>method chaining</em>. Zie je dat regeltje\n<strong>s = get_shakey</strong> eenzaam en alleen staan?\nJe zou <strong>[&ldquo;William Shakespeare&rdquo;].select { |k, v|</strong> achter <em>get_shakey</em>\nkunnen zetten (zonder punt in dit geval).</p>\n","load_code":"prev"},
"41":{"lang":"NL","title":"Eind Goed Al goed","chapter":"N","answer":"All's Well That Ends Well","ok":"Eind Goed Al goed","error":"Gebruik 1605 als tweede parameter","text":"<p>We hebben nu dus wat data van het internet gehaald, we hebben geselecteerd wat we wilden\nhebben en dit uitgeprint.\nWat nu nog ? We zouden de resultaten wat mooier kunnen printen. Met het jaar er bij en\nalles netjes uitgelijnd.</p>\n\n<p>Hiervoor moeten we twee waarden op Ã©Ã©n regel zetten. Ruby heeft daar een mooie truuk\nvoor. Het werkt net als het printen van een gewone string. Bijvoorbeeld:\n<strong>puts &ldquo;Hallo, ik ben Jantje&rdquo;</strong>.\nMaar in plaats van <em>Jantje</em> gebruiken we de waarde van een variabele.</p>\n\n<p>Eerst vervangen we <strong>Jantje</strong> door <strong>#{}</strong>. Ruby weet dan dat er een variable aankomt.\nDe string wordt nu:<br>\n<strong>&ldquo;Hallo, ik ben #{naam}&rdquo;</strong>.</p>\n\n<p>We passen onze code een beetje aan:</p>\n\n<pre><code>def print_toneelstukken(jaar_van, jaar_tot)\n  get_shakey[&quot;William Shakespeare&quot;]\n    .select { |k, v|\n      jaar_van &lt;= v[&quot;finished&quot;] &amp;&amp;\n      jaar_tot &gt;= v[&quot;finished&quot;]\n    }.each { |k, v|\n      puts &quot;#{v[&quot;title&quot;].ljust(30)} #{v[&quot;finished&quot;]}&quot;\n    }\nend\nprint_toneelstukken(1600, 1605)\n</code></pre>\n\n<p>Dat <strong>.ljust(30)</strong> heb ik toegevoegd om te zorgen dat de titel altijd minimaal 30\nletters lang is. Hierdoor is het jaartal mooi links uitgelijnd (<em>left justified</em>).</p>\n\n<p>Kan jij de code zo aanpassen dat de uitvoer er zo uitziet:<br>\n<strong>1600 -&gt; As You Like It</strong></p>\n\n<h3>Eind Goed Al goed ?</h3>\n\n<p>HÃ© we zijn er nog niet. Maar het eind is in zicht!</p>\n","load_code":"prev"},
"42":{"lang":"NL","title":"Kon ik toch maar beslissen","chapter":"N","answer":"","ok":"","error":"","text":"<p>Beslissingen nemen kan in het dagelijks leven soms een probleem zijn.\nVoor ons gelukkig niet. In Ruby is dit namelijk heel gemakkelijk.</p>\n\n<pre><code>if 1 &lt; 2\n  puts &quot;Het is waar: 1 is kleiner dan 2&quot;\nend\n</code></pre>\n\n<p>Het belangrijkste woord is hier: <strong>if</strong>. If (als) kan voor of achter een methode worden\ngeplaatst. Zo:</p>\n\n<pre><code>puts &quot;Het is waar: 1 is kleiner dan 2&quot; if 1 &lt; 2\n</code></pre>\n\n<p><strong>If</strong> is een methode met Ã©Ã©n parameter. Die parameter is een Ruby uitdrukking\ndie je wilt testen.\nDe te testen uitdrukking (expression in het Engels) moet of <strong>true</strong> (waar) zijn\nof <strong>false</strong> (niet waar).</p>\n\n<p>Dit zijn wat voorbeeld uitdrukkingen:</p>\n\n<pre><code>5     &lt;= 10     # =&gt; true\n&#39;abc&#39; == &#39;def&#39;  # =&gt; false\ntrue            # =&gt; true\n123456          # =&gt; true\n0               # =&gt; true\nnil             # =&gt; false\n&#39;xyz&#39;.empty?    # =&gt; false\n&#39;a&#39; &gt; 5         # =&gt; error:\n                # comparison of String with\n                # Numeric failed\n</code></pre>\n\n<p>De te testen uitdrukking kan vele vormen aannemen. Je kan bijvoorbeeld\nletterlijk waarden opgeven (1 &lt; 2) of variabelen (a &lt; 1) of de waarde\nvan een methode gebruiken (&lsquo;xyz&rsquo;.empty?).</p>\n","load_code":""},
"43":{"lang":"NL","title":"is == is ?","chapter":"N","answer":"is niet gelijk aan 100$","ok":"Dat is beter","error":"Dit kan niet kloppen","text":"<p>Zag je dat dubbele is teken in <strong>&lsquo;abc&rsquo; == &lsquo;def&rsquo;</strong>?</p>\n\n<p>Zo&#39;n dubbele is <strong>==</strong> betekent <strong>is gelijk aan ???</strong><br>\nHet enkele is-teken die we hiervoor al vaak hebben gezien betekent:\n<strong>ken een waarde toe aan een variabele</strong> (dit heet assigment in het Engels).</p>\n\n<p>En om je nog verder in verwarring te brengen: je mag de assignment gebruiken\nbij een <strong>if</strong> methode. Een voorbeeld:</p>\n\n<pre><code>a = 0\n\nif a = 100\n  puts &quot;De uitdrukking is waar, maar a is nu: #{a}&quot;\nelse\n  puts &quot;#{a} is niet gelijk aan 100&quot;\nend\n</code></pre>\n\n<p>Wijzig de <strong>=</strong> in <strong>==</strong> en kijk wat er gebeurt.</p>\n\n<p>Gegarandeerd zal je af en toe vergeten de tweede = in te typen. Overkomt mij ook\nnog wel eens.</p>\n\n<h3>else</h3>\n\n<p>In de voorbeeld code staat ook een <strong>else</strong>. Deze hoort bij de <strong>if</strong>. De regel\nna de <em>else</em> zal worden uitgevoerd als de <em>if test uitdrukking</em> niet waar is.</p>\n\n<blockquote>\n<p>Er zijn nog meer variaties op dit als-dan-anders thema. Lees er meer over in de Ruby\n<a href=\"http://www.ruby-doc.org/core/doc/syntax/control_expressions_rdoc.html\" target=\"_blank\">documentatie</a>.</p>\n</blockquote>\n","load_code":""},
"44":{"lang":"NL","title":"Ik ben hongerig","chapter":"N","answer":"^Ik ben niet hongerig","ok":"Klopt","error":"Om 10 uur heb ik nog geen trek !","text":"<p>Dit gaat echt goed. Gaat jou gemakkelijk af allemaal, en dat terwijl je een kwartier\ngeleden nog helemaal <strong>niets van Ruby wist !</strong></p>\n\n<p>Laatste stap van dit onderdeel. We laten nu alles samenwerken als Ã©Ã©n soepele machine.</p>\n\n<p>Eerst definiÃ«ren we twee methoden. Dan nemen we een beslissing:</p>\n\n<pre><code>def hongerig?(tijdstip_in_uren)\n  puts &quot;Ik ben hongerig&quot;\n  true\nend\n\ndef eet_een(wat)\n  puts &quot;Ik eet een #{wat}\\n&quot;\nend\n\neet_een &#39;appel&#39; if hongerig?(14)\n\neet_een &#39;appel&#39; if hongerig?(10)\n</code></pre>\n\n<p>Kan jij de methode <strong>hongerig?</strong> zo aanpassen dat er <strong>&ldquo;Ik ben niet hongerig.&rdquo;</strong>\ngetoond wordt en <strong>false</strong> teruggeeft als het tijdstip kleiner is dan 12.<br>\n(Dit is de lastigste TryRuby opgave !)</p>\n","load_code":""},
"45":{"lang":"NL","title":"Samenvatting 6 We zijn er bijna","chapter":"Y","answer":"\\{\\}","ok":"Okee, een lege hash","error":"","text":"<p>Je hebt level 6 bereikt !!! Goed hoor.<br>\nEerst nog even een samenvatting:</p>\n\n<h3>Data</h3>\n\n<p>Je hebt data van het internet gehaald, een data structuur gelezen en waarden geselecteerd.</p>\n\n<h3>Iteratie</h3>\n\n<p>Je bent door alle waarden van een hash gegaan met <strong>each</strong>. En je hebt meer <strong>methodes\ngechained</strong>.</p>\n\n<h3>Netjes printen</h3>\n\n<p>En alsof dat allemaal nog niet genoeg was heb je ook nog wat variabelen heel netjes\nen leesbaar uitgeprint. Je hebt in feite al <strong>een echt programma gemaakt !</strong></p>\n\n<h3>Als</h3>\n\n<p>Je hebt jouw programma&rsquo;s naar jouw hand gezet met <strong>if</strong> en <strong>else</strong>.</p>\n\n<h2>Dus</h2>\n\n<p>Wat zou er nu nog kunnen komen ? Wat valt er nu nog te leren ?\nHa, dat is het mooie. Je hebt nu al zoveel kennis opgedaan dat we de laatste stap\nook kunnen zetten. We gaan <em>klassen</em> bekijken. Nog 2 korte onderdelen en dan ben\nje volleerd.</p>\n\n<p>Een aantal lessen terug hebben we een nieuwe hash gemaakt:</p>\n\n<pre><code>Hash.new\n</code></pre>\n","load_code":""},
"46":{"lang":"NL","title":"Geen Schoolklas, maar de Werkende Klasse","chapter":"N","answer":"","ok":"","error":"","text":"<p>De accolades <strong>{}</strong> die we eerder hebben gebruikt is gewoon een afkorting voor <strong>Hash.new</strong>.\nDe <strong>new</strong> methode wordt gebruikt om nieuwe objecten te maken van een bepaalde klasse.\nIn dit geval de Hash klasse.</p>\n\n<p>Bij klasse moet je bijvoorbeeld denken aan de &ldquo;werkende klasse&rdquo;. Een groep objecten met\ndezelfde eigenschappen: zelfde banen, huizen, kledingstijl. Wat heb je aan klassen ?</p>\n\n<h3>Blurbalizer<sup>TM</sup></h3>\n\n<p>Je hebt net een geniaal idee plan voor een nieuwe <em>app</em> bedacht. Jouw app wordt <strong>het</strong>\nnieuwe instant messaging platform. Met jouw app kunnen mensen elkaar korte berichten\nsturen. Je noemt zo&#39;n bericht een Blurb<sup>TM</sup>.\nEen Blurb<sup>TM</sup> mag 40 tekens bevatten. Je kan er ook een stemming in opnemen.</p>\n\n<h3>Hoe ga je beginnen</h3>\n\n<p>Je zou de Blurbs<sup>TM</sup> misschien op kunnen slaan in een json bestand.\nMaar hoe houd je dan bij wanneer de Blurb<sup>TM</sup> is gemaakt?\nEn als je het bestand laadt hoe ga je er dan mee om in Ruby? Stop je de Blurbs<sup>TM</sup>\nin een hash? Of een array? of een array van array&rsquo;s? Of nog iets anders?</p>\n\n<h3>Klasse</h3>\n\n<p>Ik kan je hiervoor van harte een klasse aanbevelen (class in het Engels).\nJe kent eigenlijk al een hoop Ruby klassen: Hash, Array, String.<br>\nWe kunnen zelf ook een klasse maken (geeft geen output):</p>\n\n<pre><code>class Blurb\nend\n</code></pre>\n","load_code":""},
"47":{"lang":"NL","title":"Bouwstenen","chapter":"N","answer":"","ok":"","error":"","text":"<p>Je hebt een nieuwe Blurb<sup>TM</sup> klasse gemaakt.</p>\n\n<p>Wat gaan we daar allemaal in bijhouden? De Blurb<sup>TM</sup> tekst uiteraard.\nEn de datum en tijd van posten. En de stemming van de poster.</p>\n\n<p>We hebben de eerste regel van de klasse, dit is de rest:</p>\n\n<pre><code>class Blurb\n  attr_accessor :tekst, :tijd, :stemming\nend\n</code></pre>\n\n<p>De naam van een klasse begint altijd met een hoofdletter.</p>\n\n<p>(Nog steeds geen output)</p>\n","load_code":""},
"48":{"lang":"NL","title":"Accessors, De Toegangspoorten","chapter":"N","answer":"Blurb:","ok":"Mijn eerste Blurb","error":"","text":"<p>Hee, grote klasse die Blurb<sup>TM</sup> klasse!</p>\n\n<p>In de klasse definitie staat een methode: <strong>attr_accessor</strong>.\nEr zijn allerlei <strong>attr</strong>ibute methoden. Deze voegen wat eigenschappen toe aan je klasse.\nAttributen zijn gewoon variabelen die bij een klasse horen.</p>\n\n<p>De attr_accessor methode die wij gebruikten betekent: iedereen heeft toegang (access)\ntot de klasse variabelen: tekst, tijd, en stemming.</p>\n\n<h3>Dus</h3>\n\n<p>Om een Blurb<sup>TM</sup> maken:</p>\n\n<pre><code>blurb1 = Blurb.new\nputs blurb1\nblurb1.tekst = &quot;Today Mount Hood Was Stolen!&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :tekst,:tijd,:stemming;end"},
"49":{"lang":"NL","title":"Een Object, Een Pakketje","chapter":"N","answer":"Blurb:","ok":"Blurb updated","error":"","text":"<p>Maak de Blurb<sup>TM</sup> maar af. Voeg een tijd en stemming toe:</p>\n\n<pre><code>blurb1.tijd = Time.now\nblurb1.stemming = :verdrietig\n\nputs blurb1\n</code></pre>\n","load_code":"prev;blurb1=Blurb.new;blurb1.tekst=\"Today Mount Hood Was Stolen!\""},
"50":{"lang":"NL","title":"Dat kan sneller","chapter":"N","answer":"^\\d{4}","ok":"Genoteerd","error":"","text":"<p>Je app is nu al cool. Wat dacht je er van om jezelf wat werk uit handen te nemen.\nIedere keer dat er een Blurb<sup>TM</sup> gemaakt wordt moet je de tijd van posten\ninstellen. Best vervelend niet waar?</p>\n\n<p>We kunnen een <strong>initialize</strong> (initialiseer) methode aan onze klasse toevoegen.\nDeze methode wordt uitgevoerd zodra je een nieuwe Blurb<sup>TM</sup> maakt.</p>\n\n<p>Dan kunnen we ook meteen instellen dat de maximale Blurb<sup>TM</sup> tekst lengte\n40 tekens is:</p>\n\n<pre><code>class Blurb\n  attr_accessor :tekst, :tijd, :stemming\n\n  def initialize(stemming, tekst=&quot;&quot;)\n    @tijd     = Time.now\n    @tekst    = tekst[0..39]\n    @stemming = stemming\n  end\nend\n\nBlurb.new.tijd\n</code></pre>\n\n<p>(Parameter <strong>tekst=&ldquo;&rdquo;</strong> zorgt er voor dat we zeker weten dat <em>tekst</em> een string is.\nOok als <em>Blurb.new</em> wordt aangeroepen zonder parameters.)</p>\n","load_code":""},
"51":{"lang":"NL","title":"Binnenste Buiten","chapter":"N","answer":"Blurb:","ok":"Blurb toegevoegd","error":"","text":"<p>Zag je dat er in de klasse voor de variabelen een @ teken stond (@tijd) ?</p>\n\n<p><strong>Buiten</strong> de klasse, gebruiken we accessors:</p>\n\n<blockquote>\n<p><strong>blurb.tijd = Time.now</strong>,</p>\n</blockquote>\n\n<p>maar <strong>binnenin</strong> de klasse gebruiken we <strong>object variabelen</strong>:</p>\n\n<blockquote>\n<p><strong>@tijd = Time.now</strong>.</p>\n</blockquote>\n\n<p>Het gaat om precies dezelfde variabelen maar benaderd vanuit twee verschillende delen\nvan het programma.</p>\n\n<h3>Maak nog maar eens een Blurb<sup>TM</sup></h3>\n\n<p>Als je nu een nieuwe Blurb<sup>TM</sup> maakt wordt de initialize methode aangeroepen\nom de opgegeven parameters te controleren.</p>\n\n<p>Uh, we hebben 2 parameters nodig:</p>\n\n<pre><code>blurb2 = Blurb.new :verward, &quot;I can not believe Mt. Hood was stolen!&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :tekst,:tijd,:stemming;def initialize(stemming, tekst=\"\");@tijd=Time.now;@tekst=tekst[0..39];@stemming=stemming;end;end;blurb1=Blurb.new(:verdrietig,\"Today Mount Hood Was Stolen!\")"},
"52":{"lang":"NL","title":"Even pauze voor samenvatting 7","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Ah daar ben je. En nog helemaal heel. We gaan zo verder met het af maken van jouw app,\nmaar eerst even reviewen, okee ?</p>\n\n<h3>Klassen</h3>\n\n<p>Alles in Ruby is een object. Objecten worden beschreven door een klasse definitie.\nJe hebt bijvoorbeeld wat Blurbs<sup>TM</sup> gemaakt en het gedrag van deze\nobjecten staat in de Blurb klasse.<br>\nIn andere woorden: je noemt ze Blurb objecten.<br>\nKlassen kan je gebruiken om een model te maken van echte tastbare objecten.</p>\n\n<h3>Accessors</h3>\n\n<p>Accessors zijn variabelen die bij een object horen en die je buiten de klasse\ndefinitie kunt gebruiken.<br>\n(blurb1.tijd = Time.now)</p>\n\n<h3>Object variabelen</h3>\n\n<p>Object variabelen zijn dezelfde variabelen als de accessors, maar dan <strong>binnenin</strong>\nde klasse.<br>\n(@tijd = Time.now)</p>\n","load_code":"prev;blurb2=Blurb.new :verward, \"I can not believe Mt. Hood was stolen!\""},
"53":{"lang":"NL","title":"Op eigen benen","chapter":"N","answer":"Blurbalizer:","ok":"Mijn app is gemaakt","error":"","text":"<p>Okee, de laatste loodjes. Nu begint het laatste hoofdstuk van het <em>aangrijpende,\nheroÃ¯sche</em> verhaal over Ruby.<br>\nJe weet al heel goed hoe alles werkt en hoe je het moet toepassen.\nMaar nog een klein beetje begeleiding kan vast geen kwaad.</p>\n\n<h3>Af maken die app</h3>\n\n<p>Je hebt nu wel losse Blurbs<sup>TM</sup>, maar nog geen complete app.\nEen app heeft een titel nodig, een plek om Blurbs<sup>TM</sup> te bewaren\nen een tijdbalk kan ook geen kwaad.</p>\n\n<p>ÃÃ©n keer raden. We hebben nog een klasse nodig. Ik heb hieronder alle code gezet\ndie je nodig hebt.<br>\nNeem <strong>rustig de tijd</strong> om het door te nemen. Kijk of je alles snapt.<br>\nIk heb geen haast. Ik wacht op je bij de volgende les.</p>\n\n<pre><code>class Blurbalizer\n  def initialize(titel)\n    @titel  = titel\n    @blurbs = [] # Een schoon nieuw array\n                 # om Blurbs in op te slaan\n  end\n\n  def voeg_blurb_toe(stemming, tekst)\n    # De &lt;&lt; betekent: voeg iets toe aan het einde van een array\n    @blurbs &lt;&lt; Blurb.new(stemming, tekst)\n  end\n\n  def toon_timeline\n    puts &quot;Blurbalizer: #{@titel} heeft #{@blurbs.count} Blurbs&quot;\n\n    @blurbs.sort_by { |t|\n      t.tijd\n    }.reverse.each { |t|\n      puts &quot;#{t.tekst.ljust(40)} #{t.tijd}&quot;\n    }\n  end\nend\n\nmijnapp = Blurbalizer.new &quot;De Laatste Blurbs&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :tekst,:tijd,:stemming;def initialize(stemming, tekst=\"\");@tijd=Time.now;@tekst=tekst[0..39];@stemming=stemming;end;end"},
"54":{"lang":"NL","title":"De nieuwste Blurbs","chapter":"N","answer":"Today","ok":"Bring on the blurbs","error":"","text":"<p>Daar ben je. Denk je dat je alle Blurbify<sup>TM</sup> code hebt begrepen? Vast wel.</p>\n\n<blockquote>\n<p>In de Blurbify<sup>TM</sup> klasse zitten 2 <strong>methoden</strong> (voeg_blurb_toe en\ntoon_timeline).\nEen klasse methode kan je buiten de klasse definitie gebruiken, net als accessors.</p>\n</blockquote>\n\n<p>Hoog tijd om Blurbalizer<sup>TM</sup> op te starten.\nIk heb al wat Blurbs<sup>TM</sup> voor je toegevoegd, maar als je er zelf meer\ntoe wilt voegen: leef je uit.</p>\n\n<p>Blurbs<sup>TM</sup> maken we nu niet meer rechtstreeks, maar via de <strong>voeg_blurb_toe</strong>\nmethode. Hierdoor weten we zeker dat alle nieuwe Blurbs<sup>TM</sup> worden opgeslagen\nbinnen het <strong>mijnapp</strong> object.</p>\n\n<pre><code>mijnapp.voeg_blurb_toe :stemming, &quot;Mijn Blurb tekst&quot;\n\nmijnapp.toon_timeline\n</code></pre>\n","load_code":"prev;class Blurbalizer;attr_reader :titel;def initialize(titel);@titel=titel;@blurbs=[];end;def voeg_blurb_toe(stemming, tekst);@blurbs << Blurb.new(stemming, tekst);@blurbs.each {|t| t.tijd -= 73};end;def toon_timeline;puts \"Blurbalizer: #{@titel} heeft #{@blurbs.count} Blurbs\\n\";@blurbs.sort_by { |t| t.tijd}.reverse.each { |t| puts \"#{t.tekst.ljust(40)} #{t.tijd}\"};end;end;mijnapp = Blurbalizer.new \"De Laatste Blurbs\";mijnapp.voeg_blurb_toe :verdrietig,\"Today Mount Hood Was Stolen!\";mijnapp.voeg_blurb_toe :verward,\"I can not believe Mt. Hood was stolen!\";mijnapp.voeg_blurb_toe :verdoofd,\"I am speechless!\";mijnapp.voeg_blurb_toe :boos,\"It was stolen by a giraffe !!\";mijnapp.voeg_blurb_toe :verdrietig,\"I Left my Hoodie on the Mountain!\";mijnapp.voeg_blurb_toe :boos,\"I am never going back to that mountain.\""},
"55":{"lang":"NL","title":"De Combinatie Telt","chapter":"N","answer":":-","ok":"Stemmig !","error":"","text":"<p>Door de eenvoudige onderdelen van Ruby te combineren kunnen hele mooie programma&rsquo;s\nworden gemaakt.<br>\nHier hebben we een klasse gebruikt die weer een andere klasse bevat. Ruby kan\nuitstekend met zo&#39;n aanpak overweg. Dit heeft ook een naam:<br>\n<em>object georiÃ«nteerd programmeren</em>.</p>\n\n<p>We zijn alweer bij de <strong>laatste programmeer oefening</strong> van TryRuby.\nAls je zin hebt kan je nog wat meer features toevoegen aan Blurbalizer<sup>TM</sup>.</p>\n\n<p>Misschien is het wel leuk om de stemming ook als smiley weer te geven in de\n<strong>toon_timeline</strong> methode.\nJe zou een <em>smiley</em> methode kunnen toevoegen aan de Blurb klasse en\ndie daarna gebruiken in de <em>toon_timeline</em> methode:</p>\n\n<pre><code>class Blurb\n  attr_accessor :tekst, :tijd, :stemming\n\n  def initialize(stemming, tekst=&quot;&quot;)\n    @tijd     = Time.now\n    @tekst    = tekst[0..39]\n    @stemming = stemming\n  end\n\n  def smiley\n    if    @stemming == :verdrietig\n      return &quot;:-(&quot;\n    elsif @stemming == :blij\n      return &quot;:-)&quot;\n    # Voeg hier andere stemmingen toe\n    end\n\n    # De &#39;standaard&#39; stemming\n    &quot;:-|&quot;\n  end\nend\n\nclass Blurbalizer\n  def initialize(titel)\n    @titel  = titel\n    @blurbs = []\n  end\n\n  def voeg_blurb_toe(stemming, tekst)\n    @blurbs &lt;&lt; Blurb.new(stemming, tekst)\n  end\n\n  def toon_timeline\n    puts &quot;Blurbalizer: #{@titel} heeft #{@blurbs.count} Blurbs&quot;\n\n    @blurbs.sort_by { |t|\n      t.tijd\n    }.reverse.each { |t|\n      puts &quot;#{t.tekst.ljust(40)} #{t.tijd}&quot;\n    }\n  end\nend\n\nmijnapp.toon_timeline\n</code></pre>\n","load_code":"prev"},
"56":{"lang":"NL","title":"Samenvatting 8, De Hee-Relax-Goed gedaan Samenvatting","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Dit laatste gedeelte was best inspannend. Je kunt nu even uitrusten.\nHopelijk heb je een goede indruk gekregen hoe je Ruby in het echt kunt\ngebruiken.</p>\n\n<p>Als programmeren je aanspreekt zou je verder kunnen gaan met onze eigen\n<a href=\"/playground\">TryRuby Playground</a>\nof je kunt Ruby downloaden en installeren via:\n<a href=\"https://www.ruby-lang.org/en/downloads/\" target=\"_blank\">ruby-lang.org</a></p>\n\n<p>Als je Ruby hebt geÃ¯nstalleerd op je computer kan je een tekstbestand maken,\nbijvoorbeeld: <em>mijn_eerste_programma.rb</em>.</p>\n\n<p>Met een text editor zet je er wat Ruby code in.<br>\nJe voert het uit door een commando venster te openen en dit in te voeren:</p>\n\n<pre><code>ruby mijn_eerste_programma.rb\n</code></pre>\n\n<p>Er zijn ook allerlei tools beschikbaar die een tekst editor bevatten en de Ruby\ncode meteen kunnen uitvoeren.</p>\n\n<h2>Meer informatie</h2>\n\n<p>Op deze website zijn een aantal artikelen te vinden met achtergrond informatie\nover software ontwikkelen en wat je na deze cursus kunt doen. Zijn wel\nallemaal in het Engels.</p>\n\n<h2>Feestje</h2>\n\n<p>Gefeliciteerd, je hebt de hele cursus afgerond. Je hebt nu wel een feestmuts en\neen groot stuk taart verdiend !</p>\n","load_code":"def ruby(f);puts \"Ga naar www.ruby-lang.org om Ruby te downloaden\";end;class K;attr_reader :rb;end;mijn_eerste_programma=K.new"}}