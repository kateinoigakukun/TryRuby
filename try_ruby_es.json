{"1":{"lang":"ES","title":"¿Tienes 30 minutos? ¡Prueba Ruby ahora mismo!","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Ruby es un lenguaje de programación de Japón que está revolucionando el desarrollo de software.</p>\n\n<p>La belleza de Ruby está en el equilibrio entre simplicidad y potencia.</p>\n\n<p>Escribe código Ruby en el editor y usa estos botones para navegar:</p>\n\n<ul>\n<li><strong>Run</strong> &rarr; Ejecuta el código en el editor</li>\n<li><strong>Copy</strong> &rarr; Copia el ejemplo al editor</li>\n<li><strong>Next</strong> &rarr; Avanza a la siguiente lección</li>\n<li><strong>Back</strong> &rarr; Retrocede a la lección anterior</li>\n</ul>\n\n<div class=\"foxes\">Pulsa <strong>Next</strong> para empezar a aprender.</div>\n","load_code":""},
"2":{"lang":"ES","title":"Usando el editor","chapter":"N","answer":"^\\d{1,}$","ok":"¡ Bien ! Has hecho algo de matemáticas. ¿Has visto cómo apareció la respuesta?","error":"Escribe 2 + 6 en el editor","text":"<p>La ventana del editor, abajo, es donde escribes tu código Ruby. Pulsa el botón <strong>Run</strong> y mira cómo se ejecuta.</p>\n\n<p>Por ejemplo, prueba a escribir algo de matemáticas, como:</p>\n\n<pre><code>2 + 6\n</code></pre>\n\n<p>La salida de tu programa debería aparecer en la ventana de Resultado (&ldquo;Output&rdquo;), arriba.\nDebería aparecer también una línea explicando si lo has hecho bien o mal.</p>\n\n<blockquote>\n<p>También puedes pulsar el botón <strong>Copy</strong> para copiar el ejemplo al editor.</p>\n</blockquote>\n","load_code":""},
"3":{"lang":"ES","title":"Números y Matemáticas","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Bien","error":"","text":"<p>Ruby reconoce números y símbolos matemáticos. Prueba otras operaciones como:</p>\n\n<pre><code>4 * 10\n5 - 12\n30 / 4\n</code></pre>\n","load_code":""},
"4":{"lang":"ES","title":"Mostrándolo diferente","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Bien dicho","error":"","text":"<p>¿Has notado que si escribes más de una fórmula, solo ves la respuesta de la última?\n¿Qué pasa?</p>\n\n<blockquote>\n<p>Para hacer esta web más sencilla de usar, le he dicho a Ruby que copie el resultado de tu programa en la pantalla \noutput de arriba. Para que cuando escribas una fórmula veas los resultados.\n<strong>Pero solo el último resultado</strong>. Y solo si la pantalla output está vacía.</p>\n</blockquote>\n\n<p>Así que cuando introdujiste dos o más fórmulas, Ruby solamente mostró el resultado de la última.</p>\n\n<p>¡Por supuesto, tienes la capacidad de controlar la pantalla! Simplemente escribe <strong>puts</strong> antes de cada fórmula\n(dejando un espacio entre ellos). Puts significa: *&lsquo;pon algo en la pantalla&rsquo;</p>\n\n<p>Prueba esto:</p>\n\n<pre><code>puts 4 * 10\nputs 5 - 12\nputs 30 / 4\n</code></pre>\n\n<p>Ahora quita el puts de la última fórmula y mira qué pasa.</p>\n","load_code":""},
"5":{"lang":"ES","title":"Di tu nombre","chapter":"N","answer":"[a-zA-Z]{1,1}","ok":"Perfecto, has formado un string con las letras de tu nombre.","error":"","text":"<p>Claro, los ordenadores son prácticos y rápidos para las matemáticas. Sigamos. ¿Quieres ver tu nombre al revés?</p>\n\n<p>Primero, teclea tu nombre entre comillas, así:</p>\n\n<pre><code>&quot;Juan&quot;\n</code></pre>\n","load_code":""},
"6":{"lang":"ES","title":"Di tu nombre al revés","chapter":"N","answer":"\\w+","ok":"neiB","error":"","text":"<p>Un string es un conjunto de caracteres que el ordenador puede procesar. Imagina que las letras están\nen la cuerda de la colada, y que las comillas son las pinzas que sujetan los extremos. Las comillas marcan el principio y el final.\nPara dar la vuelta a tu nombre, teclea:</p>\n\n<pre><code>&quot;Juan&quot;.reverse\n</code></pre>\n\n<p>(¡No te olvides del punto!)</p>\n","load_code":""},
"7":{"lang":"ES","title":"Contando letras","chapter":"N","answer":"^\\d+$","ok":"Sí, length también es un 'método'","error":"","text":"<p>Has usado el <strong>método</strong> reverse en tu nombre. Has hecho un string escribiendo tu nombre entre comillas. Luego has llamado al método reverse, que trabaja con strings para darle la vuelta a todas las letras.</p>\n\n<p>Ahora, veamos cuántas letras tiene tu nombre:</p>\n\n<pre><code>&quot;Juan&quot;.length\n</code></pre>\n","load_code":""},
"8":{"lang":"ES","title":"Las Repeticiones","chapter":"N","answer":"(\\w+)","ok":"Encantado de conocerte.Encantado de conocerte.Encantado de conocerte.","error":"","text":"<p>Probablemente te estés preguntando para qué vale todo esto.</p>\n\n<p>Bueno, seguro que has ido a un sitio web que te ha gritado: <strong>¡Eh, tu contraseña es demasiado corta!</strong></p>\n\n<p>Algunos programas usan ese simple código: <strong>.length</strong></p>\n\n<p>Mira esto. Multiplica tu nombre por 5:</p>\n\n<pre><code>&quot;Juan&quot; * 5\n</code></pre>\n","load_code":""},
"9":{"lang":"ES","title":"Ey, Sumario #1 Ya","chapter":"Y","answer":"NoMethodError|undefined","ok":"Nop, no es posible dar la vuelta a un número. Pulsa 'next'","error":"","text":"<p>Echemos un vistazo a lo que has aprendido en el primer minuto.</p>\n\n<h3>El editor</h3>\n\n<p>Escribir código en el editor y pulsar <strong>run</strong> te da una respuesta en la ventana de resultado.\n(Casi) todo código da una respuesta.</p>\n\n<h3>Números y strings (cadenas de texto)</h3>\n\n<p>Los números y los strings (las cadenas de texto) son los objetos de Ruby para las mates y los textos.</p>\n\n<h3>Métodos</h3>\n\n<p>Ya has usado métodos de lenguaje como dar la <strong>vuelta</strong> (reverse) o <strong>tamaño</strong> (length). Y también métodos simbólicos como la multiplicación: *<br>\n<strong>Los Métodos significan acción!</strong></p>\n\n<p>Esta es la esencia de tu aprendizaje. Coger cosas simples, jugar con ellas y convertirlas en cosas nuevas. ¿Te sientes cómodo? Seguro que sí.</p>\n\n<h2>De acuerdo</h2>\n\n<p>Hagamos algo incómodo. Intenta darle la vuelta a un número:</p>\n\n<pre><code>40.reverse\n</code></pre>\n","load_code":""},
"10":{"lang":"ES","title":"Para, estás loco de atar!","chapter":"N","answer":"^\\d{1,}$","ok":"Sólo a strings (cadenas de texto) se les puede dar la vuelta","error":"","text":"<p>No puedes darle la vuelta al número cuarenta. Imagino que puedes poner tu monitor delante del espejo, pero darle la vuelta a un número no tiene sentido.</p>\n\n<p>Ruby ha lanzado un mensaje de error que te dice que no hay un método para dar la vuelta a un número.</p>\n\n<p>Quizás, si conviertes antes el número en string:</p>\n\n<pre><code>40.to_s.reverse\n</code></pre>\n","load_code":""},
"11":{"lang":"ES","title":"Las Naranjas son diferentes de las Manzanas","chapter":"N","answer":"\\[\\]","ok":"Genial, eso es una lisa vacía","error":"","text":"<p>Y los números son distintos de las letras.</p>\n\n<p>En Ruby puedes usar métodos sobre cualquier objeto, pero algunos métodos solo funcionan con cierto tipo de cosas.</p>\n\n<p>Lo bueno es que siempre puedes convertir algo en otro tipo de cosa usando los métodos &ldquo;to&rdquo; de Ruby.</p>\n\n<ul>\n<li><strong>to_s</strong> convierte cosas en  <strong>s</strong>trings (cadenas de texto)</li>\n<li><strong>to_i</strong> convierte cosas en  <strong>i</strong>ntegers (numeros enteros)</li>\n<li><strong>to_a</strong> convierte cosas en  <strong>a</strong>rrays (listas)</li>\n</ul>\n\n<p><strong>¿Qué son las arrays?</strong></p>\n\n<p>Son listas. Escribe un par de corchetes:</p>\n\n<pre><code>[]\n</code></pre>\n","load_code":""},
"12":{"lang":"ES","title":"En la cola","chapter":"N","answer":"^\\[([-\\.\\d]+)(\\s*,\\s*[-\\d\\.]+){3,}\\]$","ok":"Excelente","error":"Prueba a añadir un cuarto número a la lista","text":"<p>Las listas (arrays) guardan cosas <strong>en algún orden</strong>.</p>\n\n<p>Como estar en la cola para comprar palomitas de maíz. Estás detrás de alguien y no se te ocurriría empujare a un lado, no? Además tienes a alguien detrás de tí, y no le pierdes de vista, correcto?</p>\n\n<p>Aquí hay una lista para tí. Números de lotería:</p>\n\n<pre><code>[12, 47, 35]\n</code></pre>\n\n<p>Prueba a añadir un número a esta lista: pon una coma detrás del 35 y a continuación un número, el espacio es opcional.</p>\n","load_code":""},
"13":{"lang":"ES","title":"Uno Levanta la Mano","chapter":"N","answer":"^47$","ok":"Correcto","error":"","text":"<p>Una lista de números de lotería. ¿Cuál es el mayor?</p>\n\n<p>Prueba: </p>\n\n<pre><code>[12, 47, 35].max\n</code></pre>\n","load_code":""},
"14":{"lang":"ES","title":"Guardando una Lista","chapter":"N","answer":"^\\[(\\d+)(,\\s*\\d+){2,}\\]$","ok":"¡Guardada!","error":"","text":"<p>Bien, bien. Pero es molesto tener que teclear esa lista cada vez que la necesitas, ¿verdad?</p>\n\n<p>Vamos a guardar nuestros números en un boleto, así:</p>\n\n<pre><code>boleto = [12, 47, 35]\n</code></pre>\n","load_code":""},
"15":{"lang":"ES","title":"Ahora Teclea Ticket","chapter":"N","answer":"\\[(\\d+(, )?){2,}\\]","ok":"¡Recuperado!","error":"","text":"<p>Ahora, escribe:</p>\n\n<pre><code>boleto\n</code></pre>\n","load_code":"boleto = [12, 47, 35]"},
"16":{"lang":"ES","title":"Salvado, Guardado","chapter":"N","answer":"\\[12, 35, 47\\]","ok":"Has ordenado la lista","error":"","text":"<p>Has almacenado tus números de la loto, guardándolos en una <strong>variable</strong> llamada boleto.\nCualquier otro nombre, como <em>listadejuan</em> hubiera funcionado también.</p>\n\n<p>Programar, te darás cuenta, consiste principalmente en trabajar con variables.</p>\n\n<p>¿Qué te parece si ordenamos los números de la lotería?</p>\n\n<p>Usa: </p>\n\n<pre><code>boleto.sort!\n</code></pre>\n\n<p>Tenías una lista. La has ordenado. La variable boleto ha cambiado. \n¿Has notado que el método _sort! tiene una gran, brillante exclamación al final?\nMuchas veces los métodos de Ruby te gritan así si modifican una variable.\nNo es nada especial, sólo una marca.</p>\n","load_code":"boleto = [12, 47, 35]"},
"17":{"lang":"ES","title":"Elemental","chapter":"N","answer":"^(12|35|47)$","ok":"Correcto","error":"Casi","text":"<p>Hemos almacenado nuestros números de lotería en la variable boleto. ¿Qué tal si los sacamos otra vez?</p>\n\n<p>Ya hemos visto que podemos obtener el número más alto con <strong>max</strong>. De igual modo, podemos\nobtener el primer (<strong>first</strong>) o último (<strong>last</strong>) elemento de la lista.\nPero, ¿y si queremos un elemento concreto?</p>\n\n<h3>[ ]</h3>\n\n<p>Ruby usa los paréntesis cuadrados [ ] para apuntar a un elemento.\nLos paréntesis cuadrados son muy comunes en Ruby.\nSon como una mirilla para apuntar a un objetivo. Exactamente.\nEstos paréntesis significan: &ldquo;Estoy buscando a ___&rdquo;. Preparados, apunten.</p>\n\n<p>Obtengamos todos nuestros números de lotería:</p>\n\n<pre><code>puts boleto[0]\nputs boleto[1]\nputs boleto[2]\n</code></pre>\n\n<p>¿Por qué usamos [0], [1], [2] y no [1], [2] y [3]? \n¿Es algún tipo de idea Zen japonesa?\nNo, a nosotros los programadores nos gusta empezar a contar desde cero. No es solo una cosa de Ruby,\nen la mayoría de lenguajes de programación los índices de este tipo suelen empezar en cero.</p>\n\n<blockquote>\n<p>Un pequeño recordatorio: puedes usar el botón <strong>Copy</strong> para copiar el ejemplo al editor.</p>\n</blockquote>\n","load_code":"boleto = [12, 47, 35]"},
"18":{"lang":"ES","title":"El Resumen #2 está con Nosotros","chapter":"Y","answer":"\\w+","ok":"¿Rima?","error":"","text":"<p>Ahora, mira cómo fue nuestro segundo minuto:</p>\n\n<h3>Errores</h3>\n\n<p>Si tratas de darle la vuelta a un número o hacer algo sospechoso, Ruby te lo dice.</p>\n\n<h3>Arrays</h3>\n\n<p>Los arrays son listas para almacenar cosas en orden.\nTambién sabemos cómo crear arrays y obtener elementos de arrays.</p>\n\n<h3>Variables</h3>\n\n<p>Las variables almacenan una cosa y le dan un nombre, usamos el signo igual para hacerlo. Así:\nboleto = [14, 37, 18].</p>\n\n<h3>2/8</h3>\n\n<p>En total hay ocho secciones. ¡Ya llevas dos octavos del camino! Por ahora son cosas simples, \n¿no crees? Las cosas interesantes te esperan más adelante.</p>\n\n<p>Cambiemos de dirección por un momento. He metido un poco de poesía para ti en una variable. \nEcha un vistazo. Escribe:</p>\n\n<pre><code>puts poema\n</code></pre>\n","load_code":"poema = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nBut when I saw it on television,\\nPlanting our flag on Halley's comet,\\nMore still did I want to eat it.\\n\""},
"19":{"lang":"ES","title":"Desafortunadamente, odias la poesía sobre tostadas","chapter":"N","answer":"(toast){0}","ok":"Excelente","error":"Me sigue oliendo a tostada","text":"<p>Mira, no importa. No tiene por qué gustarte. Arréglalo, por favor. En lugar de toast (tostada), \nprueba con un melón o algo. Prueba esto para ver el nuevo poema:</p>\n\n<pre><code>poema.gsub(&quot;toast&quot;, &quot;honeydew&quot;)\n</code></pre>\n\n<p>El método <strong>gsub</strong>  es un diminutivo de &ldquo;global substitute&rdquo; (sustitución global). Reemplaza todas las ocurrencias de &ldquo;toast&rdquo; con\n&ldquo;honeydew&rdquo; (melón chino).</p>\n","load_code":"prev"},
"20":{"lang":"ES","title":"Apunten. Fuego","chapter":"N","answer":"^\\n.ti tae ot (.+)","ok":"De acuerdo, sí. Se ha dado la vuelta el poema entero.","error":"","text":"<p>Pregunta: ¿qué pasa si le damos la vuelta a todo este poema?</p>\n\n<pre><code>poema.reverse\n</code></pre>\n","load_code":"prev"},
"21":{"lang":"ES","title":"Demasiado giro","chapter":"N","answer":"^\\[\"More still did (.+)","ok":"Sí, casi lo que queremos","error":"","text":"<p>Así que el poema entero se ha dado la vuelta, letra a letra. Pero yo solamente quería dar la vuelta a las líneas.\nMover la última línea al principio y la primera al final.</p>\n\n<p>Al revés, pero no <strong>tan</strong> al revés.</p>\n\n<p>Así es como se haría:</p>\n\n<pre><code>poema.lines.reverse\n</code></pre>\n","load_code":"prev"},
"22":{"lang":"ES","title":"Tirabuzón de Métodos en Cadena","chapter":"N","answer":"^More still did (.+)","ok":"Bien hecho, amigo mío.<br/>El método join cogió el array de líneas y las puso juntas en un string.","error":"","text":"<p>¿Qué ves? ¿Qué ha pasado? Has escrito <strong>poema.lines.reverse</strong> y ¿qué ha pasado?</p>\n\n<p>Han pasado dos cosas. Has convertido el poema en una lista usando lines.\nLines decide la forma en la que un string se divide y lo convierte en un Array.</p>\n\n<p>Luego, has dado la vuelta a esa lista. Tenías cada una de las líneas. Les diste la vuelta. Eso es todo.</p>\n\n<p>Añadamos un nuevo método al final de la cadena:</p>\n\n<pre><code>puts poema.lines.reverse.join\n</code></pre>\n\n<p>Combinar métodos así se llama <em>encadenar métodos</em>.</p>\n","load_code":"prev"},
"23":{"lang":"ES","title":"De Todos los Resúmenes, #3 Ya Está Aquí","chapter":"Y","answer":"\\{\\}","ok":"¡Has creado un Hash vacío!","error":"","text":"<h3>Exclamaciones</h3>\n\n<p>Los métodos pueden tener exclamaciones (y también interrogaciones) en el nombre.\nSolamente están ahí para explicar mejor su función. Nada importante.</p>\n\n<h3>Manipulación de Strings</h3>\n\n<p>Buscar y modificar strings</p>\n\n<h3>Encadenar</h3>\n\n<p>Encadenar métodos te permite hacer mucho más trabajo. Partir un poema, darle la vuelta, volverlo a ensamblar:</p>\n\n<p><strong>poema.lines.reverse.join</strong></p>\n\n<p>En este punto, puedes jugar con el poema un poco más. Puedes encontrar <a href=\"http://ruby-doc.org/core/classes/String.html\" target=\"_blank\">aquí</a> una lista completa de todos los métodos de String.</p>\n\n<p>Adelante, prueba algunos de ellos como: poema.downcase o poema.swapcase</p>\n\n<h2>¿Listo?</h2>\n\n<p>Cuando estés listo para seguir, teclea:</p>\n\n<pre><code>libros = {}\n</code></pre>\n","load_code":"prev"},
"24":{"lang":"ES","title":"Un Diminuto Libro En Blanco","chapter":"N","answer":"^(esplendido|muy_bueno|mediocre|malo|abismal)$","ok":"Sí, eso es una nueva reseña","error":"Usa uno de :esplendido, :muy_bueno, :mediocre, :malo, :abismal.<br/>No te olvides los dos puntos.","text":"<p>Has creado un <strong>hash</strong> vacío. Un hash es como un array, salvo que cada uno de sus elementos tiene un nombre.</p>\n\n<p>Vamos a meter algunas mini-reseñas de libros en nuestro nuevo hash. Aquí está nuestro sistema de puntuación:</p>\n\n<ul>\n<li>:esplendido &rarr; una obra maestra</li>\n<li>:muy_bueno &rarr; lo he disfrutado, sí</li>\n<li>:mediocre &rarr; genial y terrible a partes iguales</li>\n<li>:malo &rarr; notablemente malo</li>\n<li>:abismal &rarr; siniestro total</li>\n</ul>\n\n<p>Para puntuar un libro, pon el título entre paréntesis cuadrados y la puntuación después del igual. Por ejemplo:</p>\n\n<pre><code>libros[&quot;El Arco Iris de Gravedad&quot;] = :esplendido\n</code></pre>\n\n<blockquote>\n<p>Es momento de contarte que las lecciones de TryRuby son independientes unas de otras.\nAsí que si te vuelves loco escribiendo reseñas ahora, solo las podrás usar en esta lección.\nSi quieres usar tus reseñas en la siguiente lección, te recomiendo que las copies y las pegues.\nPero no te preocupes demasiado, cada lección tiene suficiente contenido predefinido para que juegues con él.</p>\n</blockquote>\n","load_code":"libros = {}"},
"25":{"lang":"ES","title":"Más mini-reseñas","chapter":"N","answer":"[3-9]","ok":"Ves, el método length funciona con strings, arrays y hashes.","error":"","text":"<p>Sigue, rellénalo con reseñas. Y, si quieres ver la lista entera, teclea: <strong>puts libros</strong></p>\n\n<p>Las puntuaciones son: :esplendido, :muy_bueno, :mediocre, :malo y :abismal</p>\n\n<p>Estas puntuaciones no son strings. Cuando pones dos puntos delante de una palabra, obtienes un <strong>símbolo</strong>.\nLos símbolos son más baratos que los strings (en cuanto a memoria del ordenador). Si usas una palabra muchas veces\na lo largo de tu programa, mejor usa un símbolo. En lugar de tener miles de copias de esa palabra en memoria, \nel ordenador solamente almacenará el símbolo <strong>una vez</strong>.</p>\n\n<p>Y más importante, un símbolo indica que no se trata de una palabra cualquiera, sino de algo que tiene significado para tu programa.</p>\n\n<p>Introduce 2 reseñas más, usa <strong>libros.length</strong> para ver cuántas reseñas tienes en el hash:</p>\n\n<pre><code>libros[&quot;El fin profundo&quot;]  = :abismal\nlibros[&quot;Colores vivientes&quot;] = :mediocre\n\nputs libros\n\nputs libros.length\n</code></pre>\n","load_code":"libros = {\"El Arco Iris de Gravedad\" => :esplendido}"},
"26":{"lang":"ES","title":"Espera, ¿me gustó El Arco Iris de Gravedad?","chapter":"N","answer":"^(esplendido|muy_bueno|mediocre|malo|abismal)$","ok":"Me gustó mucho","error":"","text":"<p>Una gran cosa de Ruby es que normalmente se reutilizan los nombres, lo que significa que hay menos nombres que memorizar.</p>\n\n<p>Recuerda cómo se obtenían elementos de un array usando un número:\n<strong>puts boleto[1]</strong>.</p>\n\n<p>Para un hash, funciona igual, excepto que no usamos un número para obtener un elemento, sino un nombre.</p>\n\n<p>Así que si quieres consultar una de tus antiguas reseñas, pon el título en el cuadrado. Pero no pongas un igual.\nAsí:</p>\n\n<pre><code>puts libros[&quot;El Arco Iris de Gravedad&quot;]\n</code></pre>\n","load_code":"libros = {\"El Arco Iris de Gravedad\" => :esplendido, \"El fin profundo\" => :abismal, \"Colores vivientes\" => :mediocre}"},
"27":{"lang":"ES","title":"Hashes como Parejas","chapter":"N","answer":"^\\[\".*\"\\]","ok":"Encontraste las claves","error":"","text":"<p>Ten en cuenta que los hashes no guardan las cosas en orden. Ese no es su trabajo. Simplemente emparejan dos cosas: una <strong>clave</strong> y un <strong>valor</strong>.</p>\n\n<p>En tus reseñas, el título del libro es la clave, y la puntuación es el valor.</p>\n\n<p>Si quieres ver solo los títulos de todos los libros que has reseñado:</p>\n\n<pre><code>libros.keys\n</code></pre>\n\n<p>Puedes probar también con .values en lugar de .keys</p>\n","load_code":"prev"},
"28":{"lang":"ES","title":"¿Eres severo?","chapter":"N","answer":"\"mediocre\"","ok":"¡Genial! Has hecho un marcador de puntuaciones.","error":"","text":"<p>¿Estás siendo severo e injusto con tus puntuaciones? Hagamos la cuenta con un nuevo hash <strong>puntuaciones</strong>:</p>\n\n<p>Veamos, contemos tus reseñas. Sigue conmigo. Teclea:</p>\n\n<pre><code>puntuaciones = Hash.new {0}\n\nlibros.values.each { |puntuacion|\n  puntuaciones[puntuacion] += 1\n}\n\nputs puntuaciones\n</code></pre>\n\n<p>La linea vertical en el código es el carácter &ldquo;pipe&rdquo;, probablemente lo encontrarás en la tecla del 1 (pulsa Alt gr y el 1).</p>\n\n<p>El <em>+=1</em> significa: incrementa el valor en 1.</p>\n\n<p>No te preocupes si no entiendes todo lo que está pasando. Todo será explicado en su momento.</p>\n","load_code":"libros = {\"El Arco Iris de Gravedad\" => :esplendido, \"El fin profundo\" => :abismal, \"Colores vivientes\" => :mediocre, \"Abejorros\" => :mediocre}"},
"29":{"lang":"ES","title":"El Total","chapter":"N","answer":"\\w+","ok":"¡Requeteolé!","error":"","text":"<p>Una de las impresionantes novedades que acabamos de usar es un <strong>bloque</strong>. Vamos a explorar \nun poco más en esta lección y en la siguiente. Pero básicamente, un bloque es un poco de código Ruby\nrodeado de llaves ({}).</p>\n\n<p>Probemos otro bloque:</p>\n\n<pre><code>5.times { print &quot;¡Olé! &quot; }\n</code></pre>\n\n<p>Los bloques siempre se asocian a métodos. Por ejemplo el método <strong>times</strong>, que coge el bloque y ejecuta el código muchas veces (en nuestro ejemplo: cinco veces).</p>\n","load_code":""},
"30":{"lang":"ES","title":"¿Quién da la vez?","chapter":"N","answer":"^[0-9]$","ok":"Perfecto, justo a tiempo.","error":"Ejecuta el bloque entre 0 y 9 veces.","text":"<p>Como vimos en el primer ejemplo de un bloque (contando puntuaciones), podemos pasar una variable al bloque.\nQué valores <strong>se le pasan</strong> es algo que determina el método que ejecuta el bloque.</p>\n\n<p>Los valores <strong>recibidos</strong> por el bloque se colocan en la variable que aparece al principio del bloque, entre las barras verticales: |</p>\n\n<p>Probémoslo con este bloque:</p>\n\n<pre><code>5.times { |vez|\n  puts vez\n}\n</code></pre>\n\n<p>Aquí, el método <strong>.times</strong> envía un valor a la variable <strong>|vez|</strong>. Pero date cuenta que la variable vez solo se conoce dentro del bloque.</p>\n\n<blockquote>\n<p>¿Te has dado cuenta de que puedes partir el código en varias líneas? Lo hace más fácil de leer.</p>\n</blockquote>\n","load_code":""},
"31":{"lang":"ES","title":"Llegando al resumen #4","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Esta última lección ha sido un poco más larga. Probablemente habrás usado hasta tres minutos aprendiendo acerca de:</p>\n\n<h3>Hashes</h3>\n\n<p>El pequeño diccionario con las páginas curvas: <strong>{}</strong></p>\n\n<h3>Símbolos</h3>\n\n<p>Pequeñas y eficientes palabras clave, con dos puntos, como <strong>:esplendido</strong></p>\n\n<h3>Bloques</h3>\n\n<p>Trozos de código que se pueden añadir a muchos métodos de Ruby. Aquí está el código que usaste para calcular la cuenta de puntuaciones:\n<strong>libros.values.each { |puntuacion| puntuaciones[puntuacion] += 1 }</strong></p>\n\n<h3>Siguiente</h3>\n\n<p>En la siguiente leccion ahondaremos un poco más en los métodos.</p>\n","load_code":""},
"32":{"lang":"ES","title":"to (be) or not to (be)","chapter":"N","answer":"","ok":"","error":"","text":"<p>Otra pequeña cosa sobre la que no hemos hablado abiertamente: los argumentos de los métodos.\n¿Recuerdas cuando cambiamos el poema un poco? Usamos:\n<strong>poema.gsub(&ldquo;toast&rdquo;, &ldquo;honeydew&rdquo;)</strong></p>\n\n<p>El método gsub necesita dos argumentos, que le pasamos incluyendo dos strings entre paréntesis.\n<em>Los argumentos le dicen al método exactamente qué hacer.</em></p>\n\n<h3>Paréntesis</h3>\n\n<p>De hecho, la mayoría de las veces a Ruby no le importa si omites los paréntesis. Esto también habría funcionado:</p>\n\n<p><strong>poema.gsub &ldquo;toast&rdquo;, &ldquo;honeydew&rdquo;</strong></p>\n\n<p>Ya hemos usado también otro método con un parámetro. Muchas veces, de hecho, aunque no era demasiado obvio:</p>\n\n<pre><code>puts &quot;Hola&quot;\nputs(&quot;Hola&quot;)\n</code></pre>\n\n<p>Sí, <strong>puts</strong> también es un método. Para Ruby es lo mismo usar puts con o sin paréntesis, pero la versión sin paréntesis es un poco más fácil de leer. ¡ Y ahorra tiempo !</p>\n\n<blockquote>\n<p>Así que la conclusión es que puedes hacer lo que quieras con los paréntesis,\nmientras tu código se lea fácilmente.</p>\n</blockquote>\n\n<h3>to (be) or not to (be)</h3>\n\n<p>Si <em>to</em> es un método y <em>be</em> es un argumento, ahora sabemos la respuesta a esta pregunta milenaria.\nEs una cuestión de preferencia si quieres <em>to be</em> or <em>to(be)</em>.</p>\n\n<p>¿Tienes ganas de más Shakespeare? Sigue leyendo.</p>\n","load_code":"poema = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nYada yada yada\\n\""},
"33":{"lang":"ES","title":"La fierecilla domada","chapter":"N","answer":"^domar","ok":"Bien, bien.","error":"","text":"<p>Ya sabes cómo usar Ruby totalmente. Quiero decir que tienes controlado lo esencial.\nSimplemente tienes que conocer más métodos y probar bloques más complejos.</p>\n\n<p>Pero hay una parte de Ruby que no hemos tratado: cómo hacer tus propios métodos.\n<strong>¡Ejem!</strong> Pongámonos a ello, pues.</p>\n\n<p>Además de usar los métodos predefinidos por Ruby (como puts, sort, times), puedes definir\ntus propios métodos. ¿Por qué es una buena idea? Por dos razones:</p>\n\n<h3>Para hacer tu programa más corto</h3>\n\n<p>Si tienes que hacer la misma cosa en más de una parte de tu código, es más fácil poner ese trozo de código en un método aparte.\nDe esta manera, tu código será más corto.</p>\n\n<h3>Para hacer tu código más fácil de leer</h3>\n\n<p>Supón que tu programa necesita hacer muchas cosas distintas.\n<strong>Podrías</strong> meter tódo el código en una sola pieza, pero sería muy difícil de leer y entender después.</p>\n\n<p>En su lugar deberías dividir tu código en distintos métodos y darle a cada uno un nombre fácil de entender.\nTe lo agradecerás a ti mismo después.</p>\n\n<p>¿Cómo se define un método? Así:</p>\n\n<pre><code>def domar( numero_de_fierecillas )\nend\n</code></pre>\n","load_code":""},
"34":{"lang":"ES","title":"En Ruby, Def Leppard significa: define el método Leppard","chapter":"N","answer":"^domar","ok":"Domar no es aburrido","error":"","text":"<p>Estupendo, lo has hecho. Estás haciendo tu propio método. Se empieza por def, seguido del nombre del método.\nY una lista de los argumentos que el método va a necesitar. ¡ No suena nada difícil ni peligroso !\nLo único que falta es rellenarlo con Ruby y terminarlo con end.</p>\n\n<p>Aquí está el código:</p>\n\n<pre><code>def domar( numero_de_fierecillas )\n  numero_de_fierecillas.times {\n    puts &quot;Domé una fierecilla&quot;\n  }\nend\n</code></pre>\n\n<blockquote>\n<p><strong>P.D.</strong><br>\nSi no has entendido el título:\n<a href=\"http://es.wikipedia.org/wiki/Def_Leppard\" target=\"_blank\">Def Leppard</a>\nes el nombre de, una vez famoso, grupo británico.</p>\n</blockquote>\n","load_code":""},
"35":{"lang":"ES","title":"The Ripened Fruit of Your Own Creation","chapter":"N","answer":"^Domé una fierecilla","ok":"Así aprenderán esas fierecillas.","error":"","text":"<p>Ha nacido un nuevo método. Usémoslo:</p>\n\n<pre><code>domar 5\n</code></pre>\n","load_code":"def domar(numero_de_fierecillas); numero_de_fierecillas.times {puts \"Domé una fierecilla\"}; end;"},
"36":{"lang":"ES","title":"Dar y recibir","chapter":"N","answer":"\\d+","ok":"Perfecto.","error":"","text":"<p>La mayoría de los métodos no solo reciben parametros de entrada, pero también <strong>devolverán algo</strong>.\nHe cambiado tu método un poco para que te devuelva un valor. Pruébalo:</p>\n\n<pre><code>def domar( numero_de_fierecillas )\n  numero_de_fierecillas.times {\n    puts &quot;Domé una fierecilla&quot;\n  }\n  return numero_de_fierecillas\nend\n\nputs domar(3)\n</code></pre>\n\n<h3>Return</h3>\n\n<p>Y cómo te estás volviendo tan experto y avanzado, una consejo más:\npuedes omitir la palabra <strong>return</strong> de la última línea del método.\nRuby automágicamente devolverá el último valor que se haya usado dentro del método.</p>\n\n<p>Así que podemos cambiar la última línea a esto: <strong>numero_de_fierecillas</strong>.</p>\n\n<p>Pero como el método <strong>.times</strong> también devuelve el <strong>numero_de_fierecillas</strong> podemos eliminar la última línea completamente.\n¡ Resulta que nuestra versión original del método ya era la que queríamos !</p>\n","load_code":""},
"37":{"lang":"ES","title":"¿Hola, quién está ahí? ¡ Y el resumen #5 agita su sombrero !","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Bien hecho, bien hecho, bien hecho, ¡ bien hecho !</p>\n\n<p>De verdad, de verdad, de verdad, ¡ de verdaaaaaaaaaad !</p>\n\n<p>Aquí hay un resumen de los últimos minutos de tu vida:</p>\n\n<h3>Métodos</h3>\n\n<p>Los métodos se pueden definir con <strong>def</strong> y tienen un nombre. Los métodos hacen tu programa más corto y fácil de leer.</p>\n\n<h3>Parámetros</h3>\n\n<p>Los métodos pueden recibir parámetros.</p>\n\n<h3>Valor de retorno</h3>\n\n<p>Los métodos (casi) siempre devuelven un valor.</p>\n\n<h2>Ahora</h2>\n\n<p>&ldquo;To (be) or not to (be)&rdquo; ya no es una incógnita para ti. ¿Listo para más Shakespeare?</p>\n","load_code":""},
"38":{"lang":"ES","title":"El mundo es nuestro","chapter":"N","answer":"^\\{\\\"William","ok":"Bien. Un poco difícil de leer","error":"","text":"<p>Hasta ahora hemos ejecutado programas que usan solamente cosas que hemos tecleado nosotros mismos.\nLo cual está bien, quiero decir, todos esos &ldquo;Olé&rdquo; fueron épicos, pero esto es la era de Internet, así que\nya es hora de incluir el resto del mundo en nuestros esfuerzos.</p>\n\n<p>Hay muchos, muchos, muchos sitios web a los que les puedes pedir información. Por ejemplo\neste enlace te dará todos los <a href=\"http://news.google.com/news/section?q=ruby&output=rss\" target=\"_blank\">Feeds de noticias de Google</a> sobre Ruby.</p>\n\n<p>Tu navegador probablemente te lo muestra muy bonito. Si miras al código fuente de la ṕágina (Ctrl+U)\nverás una larga cadena de texto extrañamente formateado. En el ejemplo de Google, está en el formato <strong>rss</strong>.</p>\n\n<h3>Formatos</h3>\n\n<p>Hay muchos otros formatos, con nombres extraños, disponibles y que se usan en la web, como:\nhtml, xml y json. Sí, incluso este mismo sitio web utiliza un par de ellos.</p>\n\n<p>He preparado un método para ti que recogerá una lista de las obras completas de William\nShakespeare de internet. (No te preocupes, de hecho proviene del mismo servidor donde se ejecuta este sitio web, así que no estamos molestando a nadie.)</p>\n\n<p>Obtén la información con:</p>\n\n<pre><code>get_shakey\n</code></pre>\n","load_code":"def get_shakey;JSON.parse(\"{\\\"William Shakespeare\\\": {\\\"1\\\": {\\\"titulo\\\": \\\"Los dos hidalgos de Verona\\\", \\\"terminado\\\": 1591},\\\"2\\\": {\\\"titulo\\\": \\\"La fierecilla domada\\\", \\\"terminado\\\": 1591},\\\"3\\\": {\\\"titulo\\\": \\\"Enrique VI, Parte 2\\\", \\\"terminado\\\": 1591},\\\"4\\\": {\\\"titulo\\\": \\\"Enrique VI, Parte 3\\\", \\\"terminado\\\": 1591},\\\"5\\\": {\\\"titulo\\\": \\\"Enrique VI, Parte 1\\\", \\\"terminado\\\": 1592},\\\"6\\\": {\\\"titulo\\\": \\\"Tito Andrónico\\\", \\\"terminado\\\": 1592},\\\"7\\\": {\\\"titulo\\\": \\\"Ricardo III\\\", \\\"terminado\\\": 1593},\\\"8\\\": {\\\"titulo\\\": \\\"Eduardo III\\\", \\\"terminado\\\": 1593},\\\"9\\\": {\\\"titulo\\\": \\\"La comedia de las equivocaciones\\\", \\\"terminado\\\": 1594},\\\"10\\\": {\\\"titulo\\\": \\\"Trabajos de amor perdidos\\\", \\\"terminado\\\": 1595},\\\"11\\\": {\\\"titulo\\\": \\\"Trabajos de amor ganados\\\", \\\"terminado\\\": 1596},\\\"12\\\": {\\\"titulo\\\": \\\"Ricardo II\\\", \\\"terminado\\\": 1595},\\\"13\\\": {\\\"titulo\\\": \\\"Romeo y Julieta\\\", \\\"terminado\\\": 1595},\\\"14\\\": {\\\"titulo\\\": \\\"El sueño de una noche de verano\\\", \\\"terminado\\\": 1595},\\\"15\\\": {\\\"titulo\\\": \\\"El rey Juan\\\", \\\"terminado\\\": 1596},\\\"16\\\": {\\\"titulo\\\": \\\"El mercader de Venecia\\\", \\\"terminado\\\": 1597},\\\"17\\\": {\\\"titulo\\\": \\\"Enrique IV, Parte 1\\\", \\\"terminado\\\": 1597},\\\"18\\\": {\\\"titulo\\\": \\\"Las alegres comadres de Windsor\\\", \\\"terminado\\\": 1597},\\\"19\\\": {\\\"titulo\\\": \\\"Enrique IV, Parte 2\\\", \\\"terminado\\\": 1598},\\\"20\\\": {\\\"titulo\\\": \\\"Mucho ruido y pocas nueces\\\", \\\"terminado\\\": 1599},\\\"21\\\": {\\\"titulo\\\": \\\"Enrique V\\\", \\\"terminado\\\": 1599},\\\"22\\\": {\\\"titulo\\\": \\\"Julio Cesar\\\", \\\"terminado\\\": 1599},\\\"23\\\": {\\\"titulo\\\": \\\"Como gustéis\\\", \\\"terminado\\\": 1600},\\\"24\\\": {\\\"titulo\\\": \\\"Hamlet\\\", \\\"terminado\\\": 1601},\\\"25\\\": {\\\"titulo\\\": \\\"La decimosegunda noche\\\", \\\"terminado\\\": 1601},\\\"26\\\": {\\\"titulo\\\": \\\"Troilo y Crésida\\\", \\\"terminado\\\": 1602},\\\"27\\\": {\\\"titulo\\\": \\\"Tomás Moro\\\", \\\"terminado\\\": 1604},\\\"28\\\": {\\\"titulo\\\": \\\"Medida por medida\\\", \\\"terminado\\\": 1604},\\\"29\\\": {\\\"titulo\\\": \\\"Otelo\\\", \\\"terminado\\\": 1604},\\\"30\\\": {\\\"titulo\\\": \\\"A buen fin no hay mal tiempo\\\", \\\"terminado\\\": 1605},\\\"31\\\": {\\\"titulo\\\": \\\"El rey Lear\\\", \\\"terminado\\\": 1606},\\\"32\\\": {\\\"titulo\\\": \\\"Timón de Atenas\\\", \\\"terminado\\\": 1606},\\\"33\\\": {\\\"titulo\\\": \\\"Macbeth\\\", \\\"terminado\\\": 1606},\\\"34\\\": {\\\"titulo\\\": \\\"Antonio y Cleopatra\\\", \\\"terminado\\\": 1606},\\\"35\\\": {\\\"titulo\\\": \\\"Pericles\\\", \\\"terminado\\\": 1608},\\\"36\\\": {\\\"titulo\\\": \\\"Coriolano\\\", \\\"terminado\\\": 1608},\\\"37\\\": {\\\"titulo\\\": \\\"Cuento de invierno\\\", \\\"terminado\\\": 1611},\\\"38\\\": {\\\"titulo\\\": \\\"Cimbelino\\\", \\\"terminado\\\": 1610},\\\"39\\\": {\\\"titulo\\\": \\\"La tempestad\\\", \\\"terminado\\\": 1611},\\\"40\\\": {\\\"titulo\\\": \\\"Cardenio\\\", \\\"terminado\\\": 1613},\\\"41\\\": {\\\"titulo\\\": \\\"Enrique VIII\\\", \\\"terminado\\\": 1613},\\\"42\\\": {\\\"titulo\\\": \\\"Los dos nobles caballeros\\\", \\\"terminado\\\": 1614}}}\");end;"},
"39":{"lang":"ES","title":"Nobles caballeros","chapter":"N","answer":"^Los dos nobles caballeros$","ok":"Mucho mejor","error":"","text":"<p>Bien, ahora tenemos una lista de obras obtenidas de internet. Esta lista estaba en el formato json.\nAfortunadamente para nosotros, Ruby amablemente nos ofrece un método para convertir datos en json a un hash de Ruby.\nEl método <em>get_shakey</em> hace eso por nosotros.</p>\n\n<p>Pero como la estructura de los datos en json se mantiene en el hash, sigue siendo un poco difícil de leer.\nEscribamos un método para mostrar las obras más adecuadamente.</p>\n\n<p>Si miras detenidamente la lista de obras, verás que sigue una especie de estructura anidada\n(esto es bastante frecuente en los datos que se obtienen de internet).\nSe parece a esto:</p>\n\n<ul>\n  <li>&ldquo;William Shakespeare&rdquo;\n  <ul>\n      <li>&ldquo;1&rdquo;\n      <ul>\n        <li>&ldquo;titulo&rdquo;: &ldquo;Los dos hidalgos de Verona&rdquo;</li>\n        <li>&ldquo;terminado&rdquo;: 1591</li>\n      </ul>\n      </li>\n      <li>&ldquo;2&rdquo;\n      <ul>\n        <li>&ldquo;titulo&rdquo;: &ldquo;La fierecilla domada&rdquo;</li>\n        <li>&ldquo;terminado&rdquo;: 1591</li>\n      </ul>\n      </li>\n      <li>&hellip;</li>\n  </ul>\n  </li>\n</ul>\n\n<p>Para listas las obras, primero tenemos que acceder al elemento de primer nivel del hash &ldquo;William Shakespeare&rdquo; por su nombre.\nDespués tenemos que <strong>iterar</strong> todos los elementos bajo él.</p>\n\n<p>Ruby tiene un método para iterar. Se llama <strong>each</strong>. Lo hemos visto antes, \ncuando creamos el sistema de reseñas de libros.</p>\n\n<p>Todo lo que el método <strong>each</strong> devuelve se le pasa a un bloque:</p>\n\n<pre><code>s = get_shakey\n\ns[&quot;William Shakespeare&quot;].each { |key, val|\n  puts val[&quot;titulo&quot;]\n}\n</code></pre>\n","load_code":"prev"},
"40":{"lang":"ES","title":"Todo en conjunto","chapter":"N","answer":"^4$","ok":"Sí, Shakespeare escribió 4 obras en 1591","error":"La respuesta correcta para el año 1591 es 4","text":"<p>Supongamos que queremos saber los nombres y el número de obras escritas por Shakespeare en un año concreto.</p>\n\n<p>Ruby nos permite seleccionar (<strong>select</strong>) valores de un hash. El método select utiliza un bloque\npara definir qué tiene que seleccionar, y nos devuelve lo que encuentre.</p>\n\n<p>Podemos entonces utilizar los resultados devueltos por <strong>select</strong> en el metodo <strong>each</strong> como antes\nsimplemente añadiendolo después del bloque para el select. Esto es otro ejemplo de encadenar métodos, \nque vimos con anterioridad al darle la vuelta al poema.</p>\n\n<p>He preparado el método <strong>cuenta_obras</strong> para ti. Mira a ver si puedes averiguar cuántas obras\nescribió Shakespeare en el año <strong>1591</strong>. Prueba esto:</p>\n\n<pre><code>def cuenta_obras(anyo)\n  s = get_shakey\n\n  s[&quot;William Shakespeare&quot;]\n    .select { |k, v|\n      v[&quot;terminado&quot;] == anyo\n    }.each { |key, val|\n      puts val[&quot;titulo&quot;]\n    }.count\nend\n\nputs cuenta_obras(0)\n</code></pre>\n\n<p>¿Te has dado cuenta de cómo he encadenado el método count al final del método each?\nEsto nos da un valor de retorno para el método <strong>cuenta_obras</strong>.</p>\n\n<p>Hay otra posibilidad de encadenar. ¿Ves esa solitaria linea: <strong>s = get_shakey</strong>?</p>\n\n<p>Podrías añadir el <strong>[&ldquo;William Shakespeare&rdquo;].select { |k, v|</strong> a continuación de get_shakey\n(no se necesita punto en este caso).</p>\n\n<blockquote>\n<p>Nota: en Ruby podrías escribir año con la ñ, pero parece que Opal, lo que usamos para ejecutar Ruby en el navegador tiene problemas con estos caracteres.</p>\n</blockquote>\n","load_code":"prev"},
"41":{"lang":"ES","title":"A buen fin no hay mal tiempo","chapter":"N","answer":"A buen fin no hay mal tiempo","ok":"Cierto","error":"Usa 1605 como segundo parámetro","text":"<p>Bien, tenemos ciertos datos de internet, hemos seleccionado lo que queríamos y lo hemos imprimido en pantalla.\n¿Qué queda por mejorar? Podríamos poner más bonitos los resultados. Por ejemplo,\nañadir el año, y alinear los títulos y años.</p>\n\n<p>Eso implica imprimir varios valores en una línea. Ruby tiene una manera muy limpia de hacerlo.\nEs como imprimir un string como: <strong>puts &ldquo;Hola, me llamo Juan&rdquo;</strong>.\nPero en lugar del valor literal <em>Juan</em> podemos usar el valor de una variable.</p>\n\n<p>Primero, reemplazamos <strong>Juan</strong> con <strong>#{}</strong>. Si Ruby ve un símbolo de almohadilla # seguido de una llave de abrir {, buscará una variable entre la primera llave y la siguiente llave de cerrar }.\nAsí que podríamos usar esto: <strong>&ldquo;Hola, me llamo #{nombre}&rdquo;</strong>.</p>\n\n<p>Cambiemos nuestro código un poco:</p>\n\n<pre><code>def imprimir_obras(anyo_desde, anyo_hasta)\n  get_shakey[&quot;William Shakespeare&quot;]\n    .select { |k, v|\n      anyo_desde &lt;= v[&quot;terminado&quot;] &amp;&amp;\n      anyo_hasta   &gt;= v[&quot;terminado&quot;]\n    }.each { |k, v|\n      puts &quot;#{v[&quot;titulo&quot;].ljust(30)} #{v[&quot;terminado&quot;]}&quot;\n    }\nend\nimprimir_obras(1600, 1605)\n</code></pre>\n\n<p>He añadido <strong>.ljust(30)</strong> al título. De este modo, el título se <em>justifica a la izquierda</em> con una longitud mínima de 30 caracteres, para que los años se alineen y quede más bonito.</p>\n\n<p>A ver si puedes cambiar la salida del programa para que las obras se muestren así: <strong>1600 -&gt; Como gustéis</strong></p>\n\n<p><strong>¿A buen fin no hay mal tiempo?</strong> Todavía no hemos terminado, pero !la meta está a la vista!</p>\n","load_code":"prev"},
"42":{"lang":"ES","title":"Si supiera cómo tomar decisiones","chapter":"N","answer":"","ok":"","error":"","text":"<p>La toma de decisiones, en la vida real esto puede suponer un gran problema. No para nosotros.\nRuby hace que tomar decisiones sea muy fácil.</p>\n\n<pre><code>if 1 &lt; 2\n  puts &quot;Es cierto: 1 es menor que 2&quot;\nend\n</code></pre>\n\n<p>La palabra clave el <strong>if</strong>. If se puede situar antes o después de los métodos, así:</p>\n\n<pre><code>puts &quot;Es cierto: 1 es menor que 2&quot; if 1 &lt; 2\n</code></pre>\n\n<p><strong>If</strong> es un método que requiere un parámetro. Ese parámetro puede ser cualquier expresión que\nquieras verificar. El resultado de la expresión tiene que ser <strong>true</strong> or <strong>false</strong> (verdadero o falso).\nComo ejemplo unas cuantas expresiones y su resultado:</p>\n\n<pre><code>5     &lt;= 10     # =&gt; true\n&#39;abc&#39; == &#39;def&#39;  # =&gt; false\ntrue            # =&gt; true\n123456          # =&gt; true\n0               # =&gt; true\nnil             # =&gt; false\n&#39;xyz&#39;.empty?    # =&gt; false\n&#39;a&#39; &gt; 5         # =&gt; error:\n                # comparison of String with\n                # Numeric failed\n</code></pre>\n\n<p>La <em>expresión del if</em> puede tomar muchas formas. Puede comparar valores literales (1 &lt; 2), \nvariables (a &lt; 1) y el valor de retorno de un método (&lsquo;xyz&rsquo;.empty?).</p>\n","load_code":""},
"43":{"lang":"ES","title":"Y ahora para la sorprendente conclusión","chapter":"N","answer":"no es igual a 100$","ok":"Eso está mejor","error":"Eso no puede estar bien","text":"<p>¿Has visto los dos símbolos de igual en <strong>&lsquo;abc&rsquo; == &lsquo;def&rsquo;</strong>?</p>\n\n<p>El <strong>==</strong> significa <strong>es igual a</strong>.</p>\n\n<p>Un único símbolo de igual (que hemos visto anteriormente) significa <strong>asigna un valor a esta variable</strong>.</p>\n\n<p>Para hacer más confuso, puedes usar la asignación después de un if, así:</p>\n\n<pre><code>a = 0\n\nif a = 100\n  puts &quot;La expresión es true, pero a ahora es: #{a}&quot;\nelse\n  puts &quot;#{a} no es igual a 100&quot;\nend\n</code></pre>\n\n<p>Cambia el = por == y mira qué pasa.</p>\n\n<p>Te garantizo que se te olvidará teclear el segundo símbolo de igual con bastante frecuencia. Yo mismo me olvido a veces.</p>\n\n<h3>else</h3>\n\n<p>En el código de arriba he añadido una expresión else. Esta es la parte que se ejecutará cuando la <strong>expresión del if</strong> se evalua a false.</p>\n\n<blockquote>\n<p>Hay más variantes de este if-then-else. Puedes leer más\n<a href=\"http://www.ruby-doc.org/core/doc/syntax/control_expressions_rdoc.html\" target=\"_blank\">aquí</a>.</p>\n</blockquote>\n","load_code":""},
"44":{"lang":"ES","title":"Tengo hambre","chapter":"N","answer":"^No tengo hambre","ok":"Sí","error":"¡ No es posible tener hambre a las 10 AM !","text":"<p>Bien, esto va avanzando maravillosamente. Esto te puede parecer simple, pero recuerda que ¡ no sabías <strong>nada de nada de Ruby</strong> hace 15 minutos !</p>\n\n<p>Ultimo paso. Juntémoslo todo, ¿de acuerdo? Hagamoslo repicar todo como un conjunto de brillantes campanas en la playa bajo una gloriosa luz del sol.</p>\n\n<p>Definamos dos métodos y luego tomaremos una decisión:</p>\n\n<pre><code>def hambre?(hora_del_dia)\n  puts &quot;Tengo hambre&quot;\n  true\nend\n\ndef come(que)\n  puts &quot;Me como un #{que}\\n&quot;\nend\n\ncome &#39;manzana&#39; if hambre?(14)\n\ncome &#39;manzana&#39; if hambre?(10)\n</code></pre>\n\n<p>Mira a ver si puedes cambiar el método <strong>hambre?</strong> para que muestre <strong>&ldquo;No tengo hambre&rdquo;</strong> y devuelva false, si es antes de las 12.</p>\n","load_code":""},
"45":{"lang":"ES","title":"Resumen #6 Que Significa Que Has Llegado Lejos","chapter":"Y","answer":"\\{\\}","ok":"Bien, es un hash vacío","error":"","text":"<p>Ya eres un clérigo de Ruby de nivel 6. Quiero decir que has hecho un gran trabajo. Revisemos:</p>\n\n<h3>Datos</h3>\n\n<p>Has cargado algunos datos de internet, recorrido una estructura de datos, y seleccionado valores.</p>\n\n<h3>Interando</h3>\n\n<p>Has iterado todos los elementos de un hash y has encadenado algunos métodos más.</p>\n\n<h3>Impresion bonita</h3>\n\n<p>Si eso no fuera suficiente, has formateado e imprimido algunos valores de una manera fácil de leer para humanos.\nDe hecho <strong>¡has hecho un programa real!</strong></p>\n\n<h3>If</h3>\n\n<p>Has aprendido a controlar tus programas con declaraciones <strong>if</strong> y <strong>else</strong>.</p>\n\n<h2>Así que</h2>\n\n<p>¿Qué puede venir a continuación? ¿Qué podrás aprender ahora?\nJa, esa es la mejor parte. Has llegado tan lejos que ahora vamos a descubrir las clases.\nDos lecciones cortas más y habremos terminado.</p>\n\n<p>Anteriormente, hemos creado un hash así:</p>\n\n<pre><code>Hash.new\n</code></pre>\n","load_code":""},
"46":{"lang":"ES","title":"No una Clase del Colegio, sino una Clase Trabajadora","chapter":"N","answer":"","ok":"","error":"","text":"<p>Las llaves {} sin nada dentro, son un atajo para decir Hash.new. Este método new se usa para crear objetos\nde una cierta clase. Piensa en &ldquo;clase&rdquo; como en &ldquo;clase trabajadora &mdash; un grupo específico de objetos\nque son similares, tienen los mismos trabajos, lo mismos uniformes.\n¿Para qué se usan las clases?</p>\n\n<h3>Blurbalizer<sup>TM</sup></h3>\n\n<p>Has tenido una idea brillante para una nueva aplicación. Va a ser <strong>la</strong> siguiente plataforma de \nmensajería instantánea. Quieres una aplicación con la que la gente se pueda enviar mensajes cortos entre sí.\nLlamas a esos mensajes Blurbs<sup>TM</sup>. Un Blurb<sup>TM</sup> tiene una longitud máxima de 40 caracteres.\nTengamos también la posibilidad de definir un estado de ánimo.</p>\n\n<!---Internet realmente ha sacado de la bancarrota a los monigotes de palos y a los smileys. __¡A sentir!__-->\n\n<h3>Por dónde empezar</h3>\n\n<p>Bueno, puedes guardar los Blurbs<sup>TM</sup> en un fichero json, ¿verdad?\nPero ¿cómo mantener un registro del contenido de la entrada y la hora a la que se publicó?\nY cuando cargues el fichero, ¿cómo será en Ruby?\n¿Será un Hash? ¿O un Array? ¿O un Array de Arrays? ¿U otra cosa?</p>\n\n<h3>Clase</h3>\n\n<p>Realmente pienso que necesitarás usar una clase. Ya estás familiarizado con muchas clases:\nHash, Array, String.<br>\nHagamos una nueva (no tiene salida en pantalla):</p>\n\n<pre><code>class Blurb\nend\n</code></pre>\n","load_code":""},
"47":{"lang":"ES","title":"Las Cosas de las que están hechas las Aplicaciones","chapter":"N","answer":"","ok":"","error":"","text":"<p>Has abierto una nueva clase Blurb<sup>TM</sup>. ¿De qué estan hechas tus entradas del blog?\nEl contenido, por supuesto. También la hora a la que el Blurb<sup>TM</sup> se publicó. Y un estado de ánimo.</p>\n\n<p>Bien, ya tienes la primera línea de la clase. Aquí está el resto:</p>\n\n<pre><code>class Blurb\n  attr_accessor :contenido, :tiempo, :animo\nend\n</code></pre>\n\n<p>Los nombres de clases empiezan por mayúscula.</p>\n\n<p>(Todavía no hay salida en la pantalla)</p>\n","load_code":""},
"48":{"lang":"ES","title":"Los 'Accessors' son las extremidades colgantes","chapter":"N","answer":"Blurb:","ok":"Mi primer Blurb","error":"","text":"<p>Buena clase, amigo. Tienes una nueva clase Blurb<sup>TM</sup>.</p>\n\n<p>En la definición de la clase, usaste un método llamado attr_accessor.\nHay muchos métodos de <strong>attr</strong>ibutos como este que añaden pequeños ajustes.\nEstos atributos son simplemente variables adjuntadas a una clase.</p>\n\n<p>Pienslo de esta manera. Una clase es como una persona. Esa cosa humana con forma de estrella de ahí.\nY los atributos son las extremidades colgantes, las diferentes partes que forman el cuerpo y con las que otras\npersonas pueden extrecharle las manos.</p>\n\n<h3>Ahora</h3>\n\n<p>Para crear un Blurb<sup>TM</sup> y fijar su contenido:</p>\n\n<pre><code>blurb1 = Blurb.new\nputs blurb1\nblurb1.contenido = &quot;¡El Everest ha sido robado!&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :contenido,:tiempo,:animo;end"},
"49":{"lang":"ES","title":"El Objeto, ese Genial Pequeño Paquete","chapter":"N","answer":"Blurb:","ok":"Blurb actualizado","error":"","text":"<p>Ve y fija la hora y el ánimo del Blurb<sup>TM</sup>:</p>\n\n<pre><code>blurb1.tiempo = Time.now\nblurb1.animo = :enfermo\n\nputs blurb1\n</code></pre>\n","load_code":"prev;blurb1=Blurb.new;blurb1.contenido=\"¡El Everest ha sido robado!\""},
"50":{"lang":"ES","title":"Acelerandolo todo","chapter":"N","answer":"^\\d{4}","ok":"Apuntado","error":"","text":"<p>Genial, tu aplicación es impresionante. Vamos a hacer las cosas un poco más fáciles para ti.\nNo vas a querer fijar la hora así cada vez que publiques un Blurb<sup>TM</sup>.</p>\n\n<p>Simplemente quieres escribir el contenido y fijar el estado de ánimo, ¿verdad?</p>\n\n<p>Añadamos un método <strong>initialize</strong> a nuestra clase. Este método se llama cada vez que se crea un nuevo Blurb<sup>TM</sup>.\nA la misma vez podemos limitar la longitud del contenido del Blurb<sup>TM</sup> a 40 caracteres.</p>\n\n<pre><code>class Blurb\n  attr_accessor :contenido, :tiempo, :animo\n\n  def initialize(animo, contenido=&quot;&quot;)\n    @tiempo    = Time.now\n    @contenido = contenido[0..39]\n    @animo    = animo\n  end\nend\n\nBlurb.new.tiempo\n</code></pre>\n\n<p>(Ese parámetro <strong>contenido=&ldquo;&rdquo;</strong> está ahí para asegurarnos de que tenemos un string como contenido, aunque no le pasemos nada al método initialize).</p>\n","load_code":""},
"51":{"lang":"ES","title":"Has Enseñado a tu Aplicación a Rechazar Cosas Sin Valor","chapter":"N","answer":"Blurb:","ok":"Blurb añadido","error":"","text":"<p>¿Has visto cómo dentro de la clase usamos el símbolo arroba (@tiempo).</p>\n\n<p><strong>Fuera</strong> de la clase, usamos los accessors:</p>\n\n<blockquote>\n<p><strong>blurb.tiempo = Time.now</strong></p>\n</blockquote>\n\n<p>pero <strong>dentro</strong> usamos las <strong>variables del objeto</strong>:</p>\n\n<blockquote>\n<p><strong>@tiempo = Time.now</strong></p>\n</blockquote>\n\n<p>Son exactamente la misma cosa, pero expresada en dos sitios diferentes de tu programa.</p>\n\n<h3>Crea otro Blurb<sup>TM</sup></h3>\n\n<p>Cuando se crea un nuevo Blurb<sup>TM</sup>, se usa el método initialize para chequear los argumentos de new.</p>\n\n<p>Eh, necesitamos dos argumentos:</p>\n\n<pre><code>Blurb2 = Blurb.new :confuso, &quot;¡No puedo creer que hayan robado el Everest!&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :contenido,:tiempo,:animo;def initialize(animo, contenido=\"\");@tiempo=Time.now;@contenido=contenido[0..39];@animo=animo;end;end;blurb1=Blurb.new(:enfermo,\"¡El Everest ha sido robado!\")"},
"52":{"lang":"ES","title":"Ninguna Jirafa Ha Robado el Resumen #7","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Ah, estás aquí. Y de una pieza. Todavía tenemos que hacer realidad tu aplicación,\npero mientras tanto, revisemos, ¿de acuerdo?</p>\n\n<h3>Clases</h3>\n\n<p>Todas las cosas en Ruby son un tipo de objeto. Las clases explican los objetos, cómo funciona un cierto objeto.\nPor ejemplo, has creado unos cuantos objetos Blurb<sup>TM</sup> y esos objetos están explicados en la clase Blurb.\nDicho de otro modo: los llamamos objetos Blurb.\nPuedes usar clases para modelar (en cierto modo) los objetos de la vida real.</p>\n\n<h3>Accessors</h3>\n\n<p>Los Accessors son variables adjuntas a un objetos que se pueden usar desde <strong>fuera</strong> del objeto.\n(blurb2.tiempo = Time.now)</p>\n\n<h3>Variables de objetos</h3>\n\n<p>Las variables de objetos son las mismas variables que estás usando como accessors, pero <strong>dentro</strong> del objeto.\n(@tiempo = Time.now)</p>\n","load_code":"prev;blurb2=Blurb.new :confuso, ¡No puedo creer que hayan robado el Everest!\""},
"53":{"lang":"ES","title":"Tu Propio Territorio","chapter":"N","answer":"Blurbalizer:","ok":"Aplicación creada.","error":"","text":"<p>Bien, cerremos todo esto, chico. !Este es el último capítulo de la FASCINANTE y épica historia de Try Ruby !\nAhora que has probado un poco cómo funciona todo, ¿cómo lo vas a usar en tu casa y en la nevera de la frutería?\nEres una gran persona (una de mis favoritas), pero todavía necesitas que te guíe.</p>\n\n<h3>Completemos la aplicación</h3>\n\n<p>Tienes entradas de tu aplicación, pero una aplicación real.\nTodavía necesita un título, algún lugar para almacenar todos los Blurbs<sup>TM</sup> y una cronología, para que todo funcione bien.</p>\n\n<p>Adivina, vamos a usar otra clase. He puesto todo el código para la nueva clase de golpe.\n<strong>Tómate tu tiempo</strong> para estudiarlo.\nNo tengo prisa, te espero en la siguiente lección.</p>\n\n<pre><code>class Blurbalizer\n  def initialize(titulo)\n    @titulo  = titulo\n    @blurbs = [] # Un array nuevo y vacío para almacenar Blurbs\n  end\n\n  def crear_un_blurb(animo, contenido)\n    # El &lt;&lt; significa añadir al final del array\n    @blurbs &lt;&lt; Blurb.new(animo, contenido)\n  end\n\n  def mostrar_cronologia\n    puts &quot;Blurbalizer: #{@titulo} tiene #{@blurbs.count} Blurbs&quot;\n\n    @blurbs.sort_by { |t|\n      t.tiempo\n    }.reverse.each { |t|\n      puts &quot;#{t.contenido.ljust(40)} #{t.tiempo}&quot;\n    }\n  end\nend\n\nmi_app = Blurbalizer.new &quot;El Gran Blurb&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :contenido,:tiempo,:animo;def initialize(animo, contenido=\"\");@tiempo=Time.now;@contenido=contenido[0..39];@animo=animo;end;end"},
"54":{"lang":"ES","title":"¿De qué va todo ese Blurb?","chapter":"N","answer":"Han","ok":"Trae los blurbs","error":"","text":"<p>Aquí estás. ¿Pudiste descifrar todo lo que hace el código de la clase Blurbalizer<sup>TM</sup>?</p>\n\n<blockquote>\n<p>El la clase Blurbalizer<sup>TM</sup> hay dos <strong>métodos</strong> (crear_un_blurb y mostrar_cronologia).\nPuedes usar los métodos desde fuera de la clase, tal como hicimos con los accessors.</p>\n</blockquote>\n\n<p>Hora de usar Blurbalizer<sup>TM</sup>. He cargado ya unos Blurbs<sup>TM</sup> para ti, pero puedes añadir los tuyos propios si quieres.</p>\n\n<p>Ya no estamos creando Blurbs<sup>TM</sup> directamente, sino que usamos el <strong>método</strong> crear_un_blurb de la clase\nBlurbalizer<sup>TM</sup>. De este modo, nos aseguramos de que todos los Blurbs<sup>TM</sup> quedan almacenados \nen el objeto mi_app.</p>\n\n<pre><code>mi_app.crear_un_blurb :malhumorado, &quot;Añade un blurb aqui&quot;\n\nmi_app.mostrar_cronologia\n</code></pre>\n","load_code":"prev;class Blurbalizer;attr_reader :titulo;def initialize(titulo);@titulo=titulo;@blurbs=[];end;def crear_un_blurb(animo, contenido);@blurbs << Blurb.new(animo, contenido);@blurbs.each {|t| t.tiempo -= 73};end;def mostrar_cronologia;puts \"Blurbalizer: #{@titulo} tiene #{@blurbs.count} Blurbs\\n\";@blurbs.sort_by { |t| t.tiempo}.reverse.each { |t| puts \"#{t.contenido.ljust(40)} #{t.tiempo}\"};end;end;mi_app = Blurbalizer.new \"El Gran Blurb\";mi_app.crear_un_blurb :enfermo,\"¡Han robado el Everest!\";mi_app.crear_un_blurb :confuso,\"¡No me puedo creer que hayan robado el Everest!\";mi_app.crear_un_blurb :aturdido,\"¡Me he quedado sin palabras!\";mi_app.crear_un_blurb :de_locos,\"¡¡Lo robó una jirafa!!\";mi_app.crear_un_blurb :triste,\"¡Me había dejado mi sudadera en la montaña!\";mi_app.crear_un_blurb :rabioso,\"Jamás volveré a esa montaña.\""},
"55":{"lang":"ES","title":"Todo es combinar","chapter":"N","answer":":-","ok":"Ánimo cambiante !","error":"","text":"<p>Se pueden hacer cosas preciosas con las partes simples de Ruby, especialmente cuando las combinas y creas cosas nuevas.<br>\nAquí tenemos un programa que está hecho con una clase que contiene otra clase. Y, la verdad, a Ruby se le dan muy bien este tipo de criaturas. Se llama programación orientada a objetos.</p>\n\n<p>Hemos llegado al <strong>último ejercicio de programación</strong> de TryRuby. Si quieres, puedes añadir más características a \nBlurbalizer<sup>TM</sup></p>\n\n<p>Quizás quieres mostrar el ánimo con un smiley en el método <strong>mostrar_cronologia</strong>. Podrías incluso añadir un método <strong>smiley_para_animo</strong> a la clase Blurb<sup>TM</sup> y usarlo en el método <strong>mostrar_cronologia</strong>:</p>\n\n<pre><code>class Blurb\n  attr_accessor :contenido, :tiempo, :animo\n\n  def initialize(animo, contenido=&quot;&quot;)\n    @tiempo    = Time.now\n    @contenido = contenido[0..39]\n    @animo    = animo\n  end\n\n  def smiley_para_animo\n    if    @animo == :triste\n      return &quot;:-(&quot;\n    elsif @animo == :alegre\n      return &quot;:-)&quot;\n    # Añade otros animos aqui\n    end\n\n    # Animo por defecto\n    &quot;:-|&quot;\n  end\nend\n\nclass Blurbalizer\n  def initialize(titulo)\n    @titulo  = titulo\n    @blurbs = []\n  end\n\n  def crear_un_blurb(animo, contenido)\n    @blurbs &lt;&lt; Blurb.new(animo, contenido)\n  end\n\n  def mostrar_cronologia\n    puts &quot;Blurbalizer: #{@titulo} tiene #{@blurbs.count} Blurbs&quot;\n\n    @blurbs.sort_by { |t|\n      t.tiempo\n    }.reverse.each { |t|\n      puts &quot;#{t.contenido.ljust(40)} #{t.tiempo}&quot;\n    }\n  end\nend\n\nmi_app.mostrar_cronologia\n</code></pre>\n","load_code":"prev"},
"56":{"lang":"ES","title":"Sumario #8, El Sumario Ey-Relájate-Lo-Hiciste-Bien","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Esta última sección se tomó un momento para relajarse, y darte algunas pistas de cómo puedes usar Ruby.</p>\n\n<p>Si has disfrutado, puedes seguir con la zona de juegos <a href=\"/playground\">TryRuby Playground</a>\no descargarte e instalar Ruby:\n<a href=\"https://www.ruby-lang.org/en/downloads/\" target=\"_blank\">ruby-lang.org</a></p>\n\n<p>Una vez que tengas Ruby instalado, con un editor de textos puedes crear un archivo, digamos <em>mi_primer_programa.rb</em>, escribir algo de código Ruby y ejecutarlo abriendo una ventana de comandos y escribiendo:</p>\n\n<pre><code>ruby mi_primer_programa.rb\n</code></pre>\n\n<p>Hay un montón de herramientas de desarrollo disponibles (libres) que combinan un editor, un navegador de archivos y un intérprete de Ruby.</p>\n\n<h2>Celebrar</h2>\n\n<p>Te mereces una tarta doble-capa con doble glaseado extra y un tipo tocando una de esas guitarras dobles.\nQuiero decir, lo has conseguido, de verdad lo hiciste, has terminado! No hay ninguna duda, eres un <strong>rojo-maniaco listillo certificado!</strong></p>\n\n<h2>Más Información</h2>\n\n<p>Hay un par de artículos en esta web que pueden darte pistas de cómo seguir a partir de aquí.</p>\n","load_code":"def ruby(f);puts \"Ve a www.ruby-lang.org para descargar Ruby\";end;class K;attr_reader :rb;end;mi_primer_programa=K.new"}}