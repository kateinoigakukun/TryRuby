{"1":{"lang":"MK","title":"Имаш 30 минути? Започни со програмирање во Ruby веднаш!","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Ruby е програмски јазик од Јапонија кој го револуционизира софтверскиот развој.</p>\n\n<p>Убавината на Ruby е во неговиот баланс помеѓу едноставноста и моќта.</p>\n\n<p>Можеш да пишуваш Ruby код во едиторот и можеш да ги користиш овие копчиња за навигација:</p>\n\n<ul>\n<li><strong>Run</strong> &rarr; Го извршува кодот напишан во едиторот</li>\n<li><strong>Copy</strong> &rarr; Го копира пример кодот напишан во едиторот</li>\n<li><strong>Next</strong> &rarr; Те носи на следната лекција</li>\n<li><strong>Back</strong> &rarr; Ти дозволува да се вратиш на претходната лекција</li>\n</ul>\n\n<div class=\"foxes\">Кликни <strong>Next</strong> да започнеш со учење.</div>\n","load_code":""},
"2":{"lang":"MK","title":"Користење на едиторот","chapter":"N","answer":"^\\d{1,}$","ok":"Одлично! Употреби малку математика. Примети ли како одговорот се прикажа одма?","error":"Напиши 2 + 6 во едиторот","text":"<p>Едитор (анг. <strong>Editor</strong>) прозорецот во долниот десен агол е место за твојот Ruby код. Кликни на <strong>Run</strong>  копчето за го извршиш кодот!</p>\n\n<p>Можеш да започнеш со малку математика. На пример:</p>\n\n<pre><code>2 + 6\n</code></pre>\n\n<p>Резултатот на твојата програма треба да се прикаже во прозорецот за резултат (анг. <strong>Output</strong>), сместен во горниот десен агол.\nТаму исто така треба да има бројка која ти покажува кој е резултатот од кодот.</p>\n\n<blockquote>\n<p>Како алтернатива, можеш да кликнеш на <strong>Copy</strong> за да го ископираш код примерокот во едиторот.</p>\n</blockquote>\n","load_code":""},
"3":{"lang":"MK","title":"Броеви и Математика","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Одлично","error":"","text":"<p>Ruby препознава броеви и математички симболи. Можеш да пробаш и други операции, како:</p>\n\n<pre><code>4 * 10\n5 - 12\n30 / 4\n</code></pre>\n","load_code":""},
"4":{"lang":"MK","title":"Со други зборови","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Супер направено","error":"","text":"<p>Дали забележа дека доколку напишеш повеќе од една формула ќе го видиш само резултатот од последната напишана линија код.\nШто се случува?</p>\n\n<blockquote>\n<p>Со цел да ја направиме оваа веб страна полесна за користење му посочив на Ruby да го ископира резултатот од твојата програма во\n<strong>Output</strong> прозорецот на врвот. Па така, кога ќе напишеш формула, исто така ќе имаш можност да го видиш и резултатот.\n<strong>Но, само последниот резултат.</strong> И само ако резултат прозорецот е сеуште празен.</p>\n</blockquote>\n\n<p>Па така, кога внесе 2 или повеќе формули, Ruby го прикажа само резултатот од последната формула.</p>\n\n<p>Се разбира ти можеш да го контролираш резултатот! Само напиши <strong>puts</strong> пред секоја формула \n(со празно место помеѓу нив). Puts значи: <em>&lsquo;прикажи (стави) нешто на екранот&rsquo;</em>.</p>\n\n<p>Пробај го следново:</p>\n\n<pre><code>puts 4 * 10\nputs 5 - 12\nputs 30 / 4\n</code></pre>\n\n<p>Сега отстрани го зборот puts од послената формула и види што ќе се случи.</p>\n","load_code":""},
"5":{"lang":"MK","title":"Кажи ни го твоето име","chapter":"N","answer":"[a-zA-Z]{1,1}","ok":"Совшрено, ти формираше стринг од буквите на твоето име","error":"","text":"<p>Секако, компјутерите се корисни и брзи во математика. Ајде да продолжиме. Сакаш да го видиш твоето име напишано во обратен редослед? </p>\n\n<p>Прво напиши го твоето име во наводници, како во примерот:</p>\n\n<pre><code>&quot;Jimmy&quot;\n</code></pre>\n","load_code":""},
"6":{"lang":"MK","title":"Кажи ни го твоето име во обратен редослед","chapter":"N","answer":"\\w+","ok":"репуС","error":"","text":"<p>Стрингот (анг. <strong>String</strong>) е сет од карактери кои компјутерот може да ги процесира. Замисли дека буквите се обесени на жица за алишта и наводниците се штипалки кои ги држат краевите. Наводниците го означуваат почетокот и крајот. </p>\n\n<p>За да го видиш твоето име во обратен редослед, напиши го следното:</p>\n\n<pre><code>&quot;Jimmy&quot;.reverse\n</code></pre>\n\n<p>(Немој да ја заборавиш точката!)</p>\n","load_code":""},
"7":{"lang":"MK","title":"Броење на Букви","chapter":"N","answer":"^\\d+$","ok":"Да. Length е исто така 'метод'","error":"","text":"<p>Го искористи reverse <strong>методот</strong> за твоето име! Со ставање на твоето име во наводници ти направи стринг. Потоа, го повика \nreverse методот, кој фунцкионира за стрингови и ги подредува буквите во обратен редослед.</p>\n\n<p>Сега, ајде да видиме од колку букви се содржи твоето име:</p>\n\n<pre><code>&quot;Jimmy&quot;.length\n</code></pre>\n","load_code":""},
"8":{"lang":"MK","title":"Повторувања","chapter":"N","answer":"(\\w+)","ok":"Мило ми е што те запознав.Мило ми е што те запознав.Мило ми е што те запознав.","error":"","text":"<p>Сега, сигурно се прашуваш за што служи сето ова.</p>\n\n<p>Па, сигурно си посетил страна која скоро и да викала, <strong>Извинете, вашата лозинка е премногу кратка!</strong></p>\n\n<p>Гледаш, некои програми користат многу едноставен <strong>.length</strong> код.</p>\n\n<p>Погледни го ова. Ајде да го помножиме твоето име со бројот 5.</p>\n\n<pre><code>&quot;Jimmy&quot; * 5\n</code></pre>\n","load_code":""},
"9":{"lang":"MK","title":"Резиме на делот #1. Толку брзо?!","chapter":"Y","answer":"NoMethodError|undefined","ok":"Не, не е можно да го прикажеш бројот во обратен редослед. Кликни 'Next'","error":"","text":"<p>Ајде да погледнеме што сѐ научи во овие неколку воведни минути.</p>\n\n<h3>Едитор</h3>\n\n<p>Пишувањето на код во едиторот и кликање на копчето Run ти го дава одговорот во прозорот насловен  Output (мкд. резултат).\n(Скоро) секој код дава некаков резултат/одговор.</p>\n\n<h3>Броеви и стрингови</h3>\n\n<p>Броевите и стринговите претставуваат математички и текст објекти во Ruby.</p>\n\n<h3>Методи</h3>\n\n<p>Ти користеше методи чие име е блиско на Англискиот-јазик, и тоа: reverse и length. И симболички методи како што е\nметодот за множење: * \n<strong>Методите значат извршување на некаква активност!</strong></p>\n\n<p>Ова е основата за твоето учење. Земање на едноставни работи, манипулирање со нив и нивна трансформација во \nнови работи. Се чувствуваш комфортно, нели? Ти ветувам дека си.</p>\n\n<h2>Во ред,</h2>\n\n<p>Ајде да направиме нешто некомфортно. Пробај да го прикажеш бројот во обратен редослед.</p>\n\n<pre><code>40.reverse\n</code></pre>\n","load_code":""},
"10":{"lang":"MK","title":"Стоп, ова е апсурдно!","chapter":"N","answer":"^\\d{1,}$","ok":"Само стринговите можат да бидат прикажани во обратен редослед","error":"","text":"<p>Не можеш да го прикажеш бројот четириесет во обратен редослед. Можеш да го држиш мониторот пред огледало, но прикажување на број во обратен редослед едноставно нема смисла. </p>\n\n<p>Ruby прикажа порака која ја објаснува грешката. Преку таа порака, Ruby ти кажува дека нема метод наречен reverse за броеви.</p>\n\n<p>Можеби ако прво го модифицираш бројот да биде стринг:  </p>\n\n<pre><code>40.to_s.reverse\n</code></pre>\n","load_code":""},
"11":{"lang":"MK","title":"Јаболката се различни од портокалите","chapter":"N","answer":"\\[\\]","ok":"Одлично, ова е празна листа","error":"","text":"<p>И броевите се различни од стринговите.</p>\n\n<p>Иако можеш да користиш методи врз било кој објект во Ruby, сепак некои методи единствено функционираат само за одредени типови.\nНо, секогаш можеш да извршиш конверзија помеѓу разни типови користејќи ги <strong>to</strong> методите во Ruby.</p>\n\n<ul>\n<li><strong>to_s</strong> врши конверзија во стрингови (<strong>s</strong> trings)</li>\n<li><strong>to_i</strong> врши конверзија во цели броеви (<strong>i</strong>  ntegers)</li>\n<li><strong>to_a</strong> врши конверзија во низи (<strong>a</strong> rrays)</li>\n</ul>\n\n<p><strong>Што се низи?!</strong></p>\n\n<p>Низите се листи. Напиши пар од загради:</p>\n\n<pre><code>[]\n</code></pre>\n","load_code":""},
"12":{"lang":"MK","title":"Чекање во ред","chapter":"N","answer":"^\\[([-\\.\\d]+)(\\s*,\\s*[-\\d\\.]+){3,}\\]$","ok":"Одлично","error":"Пробај да додадеш четврти број во низата","text":"<p>Низите (листите) чуваат работи <strong>во одреден редослед</strong>.</p>\n\n<p>Како стоење во ред за пуканки. Ти си позади некој, и не ни помислуваш да го истуркаш на страна,\nнели? Исто, ја приметуваш личноста која стои позади тебе, нели?</p>\n\n<p>Еве листа за тебе. Броеви за лотарија: </p>\n\n<pre><code>[12, 47, 35]\n</code></pre>\n\n<p>Пробај да додадеш уште еден број во низата: стави запирка после 35 проследена со некој број. Празното место е опционално.</p>\n","load_code":""},
"13":{"lang":"MK","title":"Некој нека крене рака","chapter":"N","answer":"^47$","ok":"Супер","error":"","text":"<p>Низа со броеви за лотарија. Кој од нив е најголем?</p>\n\n<p>Пробај го следново: </p>\n\n<pre><code>[12, 47, 35].max\n</code></pre>\n","load_code":""},
"14":{"lang":"MK","title":"Совладување на низи","chapter":"N","answer":"^\\[(\\d+)(,\\s*\\d+){2,}\\]$","ok":"Зачувано!","error":"","text":"<p>Ова е супер. Но, сигурно е здодевно да ја пишуваш повторно и повторно истата низа секогаш кога ќе ти притреба, нели?</p>\n\n<p>Ајде да ги зачуваме броевите внатре во <strong>ticket</strong>, како во примерот:</p>\n\n<pre><code>ticket = [12, 47, 35]\n</code></pre>\n","load_code":""},
"15":{"lang":"MK","title":"Сега, напиши Ticket","chapter":"N","answer":"\\[(\\d+(, )?){2,}\\]","ok":"Низата е уште тука!","error":"","text":"<p>Сега, напиши</p>\n\n<pre><code>ticket\n</code></pre>\n","load_code":"ticket = [12, 47, 35]"},
"16":{"lang":"MK","title":"Зачувано и складирано","chapter":"N","answer":"\\[12, 35, 47\\]","ok":"Ти ја подреди листата","error":"","text":"<p>Сѐ до сега се придржуваше до твоите лото броеви, ставајќи ги во <strong>променлива</strong> (анг. variable), наречена ticket.\nНо и било кое друго име, како <em>jimmyslist</em>, можеш да ставиш и би било валидно исто така.</p>\n\n<p>Во програмирањето, ќе откриеш дека најголем дел се состои во работа со променливи.</p>\n\n<p>Ајде да ги подредиме твоите лото броеви во редослед, може?</p>\n\n<p>Напиши: </p>\n\n<pre><code>ticket.sort!\n</code></pre>\n\n<p>Имаше низа. Ја подреди низата. Сега променливата ticket е изменета.\nДали примети дека <em>sort!</em> методот има голем впечатлив извичник на крајот?\nЧесто методите во Ruby имаат извичник ако сакаат да извршат промена врз истата променлива.\nНема ништо посебно во тоа, тоа е само знак.</p>\n","load_code":"ticket = [12, 47, 35]"},
"17":{"lang":"MK","title":"Елементарно","chapter":"N","answer":"^(12|35|47)$","ok":"ОК","error":"Скоро до целта","text":"<p>Па, ги зачувавме нашите лото броеви во променливата ticket. Како сега да ги извадиме повторно надвор?</p>\n\n<p>Веќе видовме дека можеме да го извадиме најголемиот број од низата со методот <strong>max</strong>. Слично, можеш да \nго извадиш <strong>првиот</strong> или <strong>последниот</strong> елемент од низата.\nНо, што ако сакаш да извадиш некој конкретен елемент?</p>\n\n<h3>[ ]</h3>\n\n<p>Ruby користи [ ] загради за да таргетира елемент.\nЗаградите се многу чести во Ruby.\nТие се како знаци кои се користат за да пронајдеш мета. Буквално.\nТие загради значат, &ldquo;Јас барам ____&rdquo;. Подготвен, нишани!</p>\n\n<p>Ајде да ги издвоиме сите лото броеви:</p>\n\n<pre><code>puts ticket[0]\nputs ticket[1]\nputs ticket[2]\n</code></pre>\n\n<p>Зошто користиме [0], [1], [2]?</p>\n\n<p>А не користиме [1], [2] и [3]? Да не е ова некаква Јапонска Зен работа?\nНе, ние компјутерџиите сакаме да започнеме со броење од нула. Тоа всушност не е само во Ruby,\nиндексирањето <em>базирано на нула</em> се користи во повеќето програмски јазици.</p>\n\n<blockquote>\n<p>Мало потсетување: можeш да го користиш <strong>Copy</strong> копчето за да го копираш код примерокот во едиторот.</p>\n</blockquote>\n","load_code":"ticket = [12, 47, 35]"},
"18":{"lang":"MK","title":"Резимето на делот #2 е тука","chapter":"Y","answer":"\\w+","ok":"Се римува ли?","error":"","text":"<p>Сега, погледни како твојата втора минута помина:</p>\n\n<h3>Грешки (анг. Errors)</h3>\n\n<p>Доколку пробаш да прикажеш број во обратен редослед или да направиш нешто некоректно, Ruby ќе ти укаже на тоа.</p>\n\n<h3>Низи (анг. Arrays)</h3>\n\n<p>Низите се листи кои зачувуваат работи во некаков редослед.\nЗнаеме како да креираме низа и како да извадиме елементи од низата.</p>\n\n<h3>Променливи (анг. Variables)</h3>\n\n<p>Променливите зачувуваат работи и им даваат име. Го употреби знакот за еднакво за да го направиш тоа. На пример,\nticket = [14, 37, 18].</p>\n\n<h3>2/8</h3>\n\n<p>Сѐ на сѐ има 8 секции. Ти си две-осмини од целта. Ова се прилично едноставни работи, нели? \nУште подобри работи следат!</p>\n\n<p>Ајде да смениме насока за момент. Зачував поезија за тебе во одредена променлива.\nПогледни. Напиши:</p>\n\n<pre><code>puts poem\n</code></pre>\n","load_code":"poem = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nBut when I saw it on television,\\nPlanting our flag on Halley's comet,\\nMore still did I want to eat it.\\n\""},
"19":{"lang":"MK","title":"За жал, Toast поезијата не ти се допаѓа","chapter":"N","answer":"(toast){0}","ok":"Прекрасно","error":"Сеуште ми мириса на toast мене","text":"<p>Види, во ред е. Не мора да ти се допаѓа. Промени го, ако баш и сакаш. Наместо toast, оди по \nлубеница или нешто друго. Пробај го следново за да ја видиш новата поема:</p>\n\n<pre><code>poem.gsub(&quot;toast&quot;, &quot;honeydew&quot;)\n</code></pre>\n\n<p><strong>gsub</strong> методот е скатено за глобална замена (анг. <strong>global substitute</strong>). Ги заменува сите прикажување на &ldquo;toast&rdquo; со\n&ldquo;honeydew&rdquo;.</p>\n","load_code":"prev"},
"20":{"lang":"MK","title":"Подготвен, нишани","chapter":"N","answer":"^\\n.ti tae ot (.+)","ok":"Во ред. Целата поема е прикажана во обратен редослед.","error":"","text":"<p>Прашање: што ќе се случи кога ќе ја прикажеме во обратен редослед целата поема?</p>\n\n<pre><code>poem.reverse\n</code></pre>\n","load_code":"prev"},
"21":{"lang":"MK","title":"Премногу пресврти","chapter":"N","answer":"^\\[\"More still did (.+)","ok":"Да, скоро до тоа што го посакуваме","error":"","text":"<p>Значи, целата поема е прикажана во обратен редослед, буква по буква. Јас само сакав да ги прикажам \nредиците во обратен редослед.\nДа ги променам местата на последната редица со првата.</p>\n\n<p>Да наназад, но не <strong>толку</strong> назад.</p>\n\n<p>Еве како:</p>\n\n<pre><code>poem.lines.reverse\n</code></pre>\n","load_code":"prev"},
"22":{"lang":"MK","title":"Прстени од врзување на методи","chapter":"N","answer":"^More still did (.+)","ok":"Добра претстава, мој пријателе!<br/>join методот ја зеде низата од редици стихови и ги спои сите заедно во стринг.","error":"","text":"<p>Па, што гледаш? Што се случи таму? Ти напиша <strong>poem.lines.reverse</strong> и што се случи?</p>\n\n<p>Се случија две работи. Ти ја претвори поемата во низа со помош на редовите стихови.\nРедовите стихови одлучија на кој начин стрингот ќе биде поделен и го претвори во Низа.</p>\n\n<p>Потоа, ја прикажа низата во обратен редослед. Ја имаше секоја редица стих. Ги прикажа во обратен редослед. И, тоа е тоа.</p>\n\n<p>Ајде да додадеме уште еден метод на крајот:</p>\n\n<pre><code>puts poem.lines.reverse.join\n</code></pre>\n\n<p>Комбинирањето, односно врзувањето на методи на ваков начин е наречен <em>method chaining</em>.</p>\n","load_code":"prev"},
"23":{"lang":"MK","title":"Од вкупниот број на Резимеа, #3 е тука","chapter":"Y","answer":"\\{\\}","ok":"Одлично! Ти направи празен hash!","error":"","text":"<h3>Извичници</h3>\n\n<p>Методите можат да содржат извичници (и прашалници) во нивното име.\nТоа е само заради подобро објаснување на нивната функционалност. Ништо страшно.</p>\n\n<h3>Манипулација на стрингови</h3>\n\n<p>Пребарување и промена на стрингови</p>\n\n<h3>Поврзување (анг. chaining)</h3>\n\n<p>Поврзувањето на методи помага кога треба да извршиш повеќе операции врз еден објект. Можеш: да ја поделиш поемата, да ја прикажеш во обратен редослед, и на крај па пак да ја склопиш:\n<strong>poem.lines.reverse.join</strong></p>\n\n<p>Во овој момент, можеби сакаш уште да си играш со поемата. Комплетната листа со методи за \nманипулација со Стрингови можеш да ја најдеш <a href=\"http://ruby-doc.org/core/classes/String.html\" target=\"_blank\">тука</a>.</p>\n\n<p>Повели и пробај нови методи, како на пример: <strong>poem.downcase</strong> или <strong>poem.swapcase</strong></p>\n\n<h2>Подготвен?</h2>\n\n<p>Кога ќе се почувствуваш спремен за следната лекција, напиши:</p>\n\n<pre><code>books = {}\n</code></pre>\n","load_code":"prev"},
"24":{"lang":"EN","title":"Мала празна книга","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"Да, ти само што додаде нов ранг","error":"Use one of splendid, quite_good, mediocre, quite_not_good, abysmal.<br/>Don't forget the colon","text":"<p>Креираше празен <strong>hash</strong>. Нash-от е како низа, со таа разлика што секој од елементите во hash-от има име.</p>\n\n<p>Ќе направиме минијатурни оцени за книгата во нашиот нов hash. Ова е нашиот систем за рангирање:</p>\n\n<ul>\n<li>:splendid &rarr; ремек-дело</li>\n<li>:quite_good &rarr; релативно добра</li>\n<li>:mediocre &rarr; ист број на добри и лоши делови</li>\n<li>:quite_not_good &rarr; релативно лоша</li>\n<li>:abysmal &rarr; премногу лоша</li>\n</ul>\n\n<p>За да рангираш книга, стави го насловот во <strong>[ ]</strong> наводници и стави го рангот после знакот за еднакво. На пример,</p>\n\n<pre><code>books[&quot;Gravitys Rainbow&quot;] = :splendid\n</code></pre>\n\n<blockquote>\n<p>Бидејќи стигна до тука, фер е да ти кажам дека сите лекции во TryRuby се одвоени една од друга.\nПа така, ако се разигра со рангирањето на книги, шансата ти е само во оваа лекција.\nДоколку сакаш да ги користиш твоите рангирања во наредната лекција, мораш да им направиш copy/paste.\nНе грижи се за ова премногу, секоја лекција има многу предефинирани работи со кои можеш да играш.</p>\n</blockquote>\n","load_code":"books = {}"},
"25":{"lang":"MK","title":"Уште оцени!","chapter":"N","answer":"[3-9]","ok":"Само што откри дека методот length одговара за стрингови, низи и hash-ови","error":"","text":"<p>Продолжи со одличната работа и наполни ги книгите со оцени. И, ако сакаш да ја видиш целата листа само напиши: <strong>puts books</strong> </p>\n\n<p>И повторно, рангирањето е: :splendid, :quite_good, :mediocre, :quite_not_good and :abysmal.</p>\n\n<p>Овие рангови не се стрингови. Кога ќе ставиш две-точки <strong>:</strong> пред прост збор, добиваш <strong>симбол</strong>.\nСимболите се „поевтини“ од стринговите (во конотација на компјутерска меморија). Доколку сакаш да користиш еден збор на повеќе места во твојата програма, користи симбол. Наместо да имаш илјадници копии од истиот збор во меморија, компјутерот ќе го зачува симболот само <strong>еднаш</strong>.</p>\n\n<p>Уште поважно, симболот ти кажува дека не е само било кој стар збор, туку има значење во твојата програма.</p>\n\n<p>Внеси уште 2 оцени за книги, и напиши <strong>books.length</strong> за да видиш колку оцени има во hash-от:</p>\n\n<pre><code>books[&quot;The deep end&quot;]  = :abysmal\nbooks[&quot;Living colors&quot;] = :mediocre\n\nputs books\n\nputs books.length\n</code></pre>\n","load_code":"books = {\"Gravitys Rainbow\" => :splendid}"},
"26":{"lang":"MK","title":"Чекај малку, ја оценив ли книгата Gravity's Rainbow?","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"Многу ми се допаѓа","error":"","text":"<p>Една од прекрасните работи во Ruby е тоа што имињата се често повторно употребливи, а тоа значи помалку имиња за паметење.</p>\n\n<p>Се сеќаваш ли како издвојувавме елементи од низа, со користење на број:<br>\n<strong>puts ticket[1]</strong>.</p>\n\n<p>Кај hash-от ова фунцкионира на ист начин, со таа разлика што кај hash-от не користиме број за да го издвоиме елементот, туку користиме име.</p>\n\n<p>Па така, ако сакаш да издвоиш некој од твоите постари оцени, повторно стави го насловот во <strong>[ ]</strong> наводници. Но, изостави го знакот за еднакво.\nИсто како во примерот:</p>\n\n<pre><code>puts books[&quot;Gravitys Rainbow&quot;]\n</code></pre>\n","load_code":"books = {\"Gravitys Rainbow\" => :splendid, \"The deep end\" => :abysmal, \"Living colors\" => :mediocre}"},
"27":{"lang":"MK","title":"Hash-овите како Парови","chapter":"N","answer":"^\\[\".*\"\\]","ok":"Ги пронајде клучевите","error":"","text":"<p>Имај на ум дека hash-овите не ги чуваат работите во редослед. Тоа не е нивна работа. Нивната работа е \nсамо да направат пар од две работи: <strong>клуч</strong> (анг. key) и <strong>вредност</strong> (анг. value).</p>\n\n<p>Во твоите оцени, името на книгата претставува клуч, а рангот претставува вредност.</p>\n\n<p>Доколку сакаш да ги видиш само насловите од сите книги што си ги оценил, напиши:</p>\n\n<pre><code>books.keys\n</code></pre>\n\n<p>Можеш да го пробаш истово и со .values, наместо со .keys.</p>\n","load_code":"prev"},
"28":{"lang":"MK","title":"Дали си строг при оценувањето на книгите?","chapter":"N","answer":"\"mediocre\"","ok":"Одлично, браво! Ти само што направи карта со твои оцени.","error":"","text":"<p>Даваш строги, нефер оцени? Ајде, да го зачуваме резултатот во нов hash <strong>ratings</strong>:</p>\n\n<p>Потоа, може да ги изброиме твоите оцени. Остани со мене. Напиши:</p>\n\n<pre><code>ratings = Hash.new {0}\n\nbooks.values.each { |rate|\n  ratings[rate] += 1\n}\n\nputs ratings\n</code></pre>\n\n<p>Правата линија во кодот се вика <strong>pipe character</strong>, која најверојатно се наоѓа над копчето Enter\nна твојата тастатура.</p>\n\n<p>Делот <strong>+= 1</strong> од код линијата <strong>ratings[rate] += 1</strong> значи: зголеми ја вредноста за 1.</p>\n\n<p>Не грижи се ако не разбираш сѐ што се случува тука. Ќе ти биде јасно подоцна.</p>\n","load_code":"books = {\"Gravitys Rainbow\" => :splendid, \"The deep end\" => :abysmal, \"Living colors\" => :mediocre, \"Bumblebees\" => :mediocre}"},
"29":{"lang":"MK","title":"Сума","chapter":"N","answer":"\\w+","ok":"Yodelay!","error":"","text":"<p>Една од прекрасните нови работи кои сега ги искористивме е <strong>блокот</strong> (анг. block). Ќе дознаеш повеќе за ова и во следната лекција. Но, во основа, блокот е мал Ruby код опкружен со <strong>{ }</strong> наводници.</p>\n\n<p>Ајде да пробаме друг блок:</p>\n\n<pre><code>5.times { print &quot;Odelay! &quot; }\n</code></pre>\n\n<p>Блоковите се секогаш поврзани за методи. Како кај <strong>times</strong> методот, кој го зема блокот и го извршува\nодново и одново. (Во нашиот пример, пет пати.)</p>\n","load_code":""},
"30":{"lang":"MK","title":"Дали имаш уште време?","chapter":"N","answer":"^[0-9]$","ok":"Одлично го примени .times методот!","error":"Изврши го кодот во блокот 0 до 9 пати","text":"<p>Како што видовме во првиот пример со блок (при броењето на рангови) може да испратиш вредност (анг. value) на блокот. \nКои вредности се <strong>испратени</strong> е одредено со методот кој го управува блокот.</p>\n\n<p>Вредностите кои се <strong>примени</strong> од блокот се сместени во променлива, која се испраќа на почетокот на блокот,\nпомеѓу два симболи: <strong>|име на променлива|</strong></p>\n\n<p>Ајде да го пробаме тоа во следниов блок:</p>\n\n<pre><code>5.times { |time|\n  puts time\n}\n</code></pre>\n\n<p>Тука, методот <strong>.times</strong> праќа вредност на променливата <strong>|time|</strong>. При тоа, запомни дека променливата time е валидна само \nво рамки на блокот.</p>\n\n<blockquote>\n<p>Примети ли дека можеш да го делиш кодот на повеќе линии. Тоа го прави полесен за читање.</p>\n</blockquote>\n","load_code":""},
"31":{"lang":"MK","title":"Стигнавме до Резиме #4","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Последнава лекција беше малку подолга. Најверојатно ти требаа три минути за да научиш:</p>\n\n<h3>Hash-ови</h3>\n\n<p>Синоним за малиот речник (анг. dictionary) со округли страни: <strong>{ }</strong></p>\n\n<h3>Симболи (анг. symbols)</h3>\n\n<p>Мал, ефективен код од зборови, пред кои се ставаат две-точки, како: <strong>:splendid</strong></p>\n\n<h3>Блокови (анг. blocks)</h3>\n\n<p>Делови код кој може да се прикачи на многу методи во Ruby. Следниот код го искористи за да го зачуваш резултатот: \n<strong>books.values.each { |rate| ratings[rate] += 1 }</strong></p>\n\n<h3>Следно</h3>\n\n<p>Во следната лекција ќе учиме подетално за методи.</p>\n","load_code":""},
"32":{"lang":"MK","title":"Да се биде или не","chapter":"N","answer":"","ok":"","error":"","text":"<p>Другата работа за која до сега немавме шанса да ја разгледаме се: аргументите, односно параметрите (анг. parameters), во методите.\nСе сеќаваш кога ја изменивме пемата? Користевме:\n<strong>poem.gsub(&ldquo;toast&rdquo;, &ldquo;honeydew&rdquo;)</strong></p>\n\n<p>gsub-методот има два агрументи кои ги пративме преку два стрингови одделени со запирка, во загради.\n<em>Аргументите им кажуваат на методите што точно да прават.</em></p>\n\n<h3>Загради</h3>\n\n<p>Всушност, за многу од методите во Ruby не се задолжителни заградите, па дури и да ги испуштиш некаде методот ќе функционира. Па така, следниот код ќе функционираше и вака:\n<strong>poem.gsub &ldquo;toast&rdquo;, &ldquo;honeydew&rdquo;</strong></p>\n\n<p>Исто така, искористивме и друг метод со параметри. Всушност, многу пати искористивме параметри иако не беше \nмногу очигледно:</p>\n\n<pre><code>puts &quot;Hello&quot;\nputs(&quot;Hello&quot;)\n</code></pre>\n\n<p>Да, <strong>puts</strong> исто така е метод. Дали ќе користиш загради или не кога го применуваш методот puts, за\nRuby е исто, со таа разлика што верзијата без загради е малку полесна за читање. И ти заштедува значително време\nво пишувањето на кодот!</p>\n\n<blockquote>\n<p>Па, сметам дека заклучокот е дека можеш да правиш што сакаш со заградите се додека твојот код\nсе чита убаво.</p>\n</blockquote>\n\n<h3>Да се биде или не / to (be) or not to (be)</h3>\n\n<p>Значи, ако <em>to</em> е метод и <em>be</em> е параметар сега знаеме како да одговориме на прашањето старо со години.\nНавистина станува збор само за лична преференција дали сакаш да биде <em>to be</em> или <em>to(be)</em>.</p>\n\n<p>Дали си расположен за Шекспир? Продолжи со читање.</p>\n","load_code":"poem = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nYada yada yada\\n\""},
"33":{"lang":"MK","title":"Припитомување на итрицата (Шекспирово дело)","chapter":"N","answer":"^tame","ok":"Многу добро!","error":"","text":"<p>Сега знаеш многу добро како да го користиш програмскиот јазик Ruby. Мислам, ги помина основите.\nСега, треба само да продолжиш да изучуваш што повеќе методи и да пробуваш што повеќе комплекси блокови.</p>\n\n<p>Но, има една страна од Ruby за која не зборувавме. Дефинирање на твои методи.\n<strong>Точно така!</strong> Ајде да ги совладаме и нив.</p>\n\n<p>Покрај тоа што можеш да ги користиш веќе дефинираните Ruby методи (како puts, sort, times), можеш\nда дефинираш твои методи. Зошто тоа е добра идеја? Две причини:</p>\n\n<h3>Да си ја направиш програма пократка</h3>\n\n<p>Ако една иста работа ти се повторува во повеќе делови од твојот код, полесно е\nистиот тој код да се стави во посебен метод. Твојот код ќе биде пократок.</p>\n\n<h3>Твојот код ќе биде лесен за читање</h3>\n\n<p>Претпостави си дека твојата програма треба да прави многу различни работи.\nДа, ти <strong>можеш</strong> да го ставиш кодот во една целина. Но, ќе биде многу тешко \nза разбирање и читање на истиот код подоцна.</p>\n\n<p>Наместо тоа, можеш да го поделиш кодот на повеќе методи, при тоа да му дадеш\nиме од Англискиот јазик кое ќе биде лесно за разбирање. Ќе бидеш благодарен на себе за тоа подоцна.</p>\n\n<p>Па, како дефинираме метод? Како во следниот пример:</p>\n\n<pre><code>def tame( number_of_shrews )\nend\n</code></pre>\n","load_code":""},
"34":{"lang":"MK","title":"Во Ruby, def leppard значи: дефинирање на метод со име Leppard","chapter":"N","answer":"^tame","ok":"Tame is not lame","error":"","text":"<p>Одлично! Веќе дефинираш твои методи. Започна со def, па следува името на методот.\nИ листа со параметри кои ќе му бидат потребни на самиот метод. Ова не е ништо страшно ниту пак опасно!\nСѐ што треба да направиш е да го пополниш методот со Ruby код и на крај да го ставиш резервираниот (анг. reserved) збор end.</p>\n\n<p>Ова е кодот:</p>\n\n<pre><code>def tame( number_of_shrews )\n  number_of_shrews.times {\n    puts &quot;Tamed a shrew&quot;\n  }\nend\n</code></pre>\n\n<blockquote>\n<p><strong>П.С.</strong><br>\nДоколку не го сфати насловот на оваа лекција,\n<a href=\"http://en.wikipedia.org/wiki/Def_Leppard\" target=\"_blank\">Def Leppard</a>\nе име на некогаш познатиот Англиски рок бенд.</p>\n</blockquote>\n","load_code":""},
"35":{"lang":"MK","title":"Зрелите плодови на твојата креација","chapter":"N","answer":"^Tamed a shrew","ok":"That'll show those shrews","error":"","text":"<p>Нов метод е дефиниран. Ајде сега да го примениме:</p>\n\n<pre><code>tame 5\n</code></pre>\n","load_code":"def tame(number_of_shrews);number_of_shrews.times{puts \"Tamed a shrew\"};end;"},
"36":{"lang":"MK","title":"Дај и земи","chapter":"N","answer":"\\d+","ok":"Само така. Браво.","error":"","text":"<p>Повеќето методи не само што бараат некои параметри како инпут (анг. input), туку и ќе дадат <strong>нешто назад</strong>.\nНаправив мала измена во методот со цел да ти врати некоја вредност. Пробај:</p>\n\n<pre><code>def tame( number_of_shrews )\n  number_of_shrews.times {\n    puts &quot;Tamed a shrew&quot;\n  }\n  return number_of_shrews\nend\n\nputs tame(3)\n</code></pre>\n\n<h3>Return</h3>\n\n<p>Па, бидејќи си толку способен и напреден, повели уште еден совет:\nможеш да го испуштиш клучниот збор <strong>return</strong> од последната линија код во методот.\nRuby автоматски ќе ја врати последната вредност што се употребила во методот.</p>\n\n<p>Па така, последната линија код може да се прикаже вака: <strong>number_of_shrews</strong>.</p>\n\n<p>Но, бидејќи методот <strong>.times</strong> исто така ќе го врати <em>бројот на shrews</em> може да\nја избришеме целата последна линија. Всушност, оригиналниот метод веќе го направи тоа што го баравме цело време!</p>\n","load_code":""},
"37":{"lang":"MK","title":"Здраво, кој е таму? Тука е Резимето #5!","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Многу добро сторено, многу добро сторено, многу добро сторено, многу добро сторено!</p>\n\n<p>Навистина, навистина, навистина, навистина, навистинаааааа!</p>\n\n<p>Ова се последните минути од твојот живот во ретроспектива:</p>\n\n<h3>Методи</h3>\n\n<p>Методите се дефинираат со резервираниот збор <strong>def</strong> и имаат име. Методите ја прават твојата\nпрограма пократка и полесна за читање.</p>\n\n<h3>Параметри</h3>\n\n<p>Методите може да имаат параметри.</p>\n\n<h3>Return вредности</h3>\n\n<p>Методите (скоро) секогаш враќаат вредност.</p>\n\n<h2>Сега</h2>\n\n<p><em>Да се биде или не</em> не е повеќе прашање за тебе. Дали си подготвен за прикажување \nповеќе од Шекспир?</p>\n","load_code":""},
"38":{"lang":"MK","title":"Светот е нашата школка (Извадок од Шекспирово дело)","chapter":"N","answer":"^\\{\\\"William","ok":"Добро. Малку потешко за читање.","error":"","text":"<p>Сѐ до сега извршувавме програми кои користат работи што сами ги пишувавме.\nШто е добро, иако <em>Odelaying</em> беше епска, ова е интернет ера и е веќе време да го приклучиме \nостатокот од светот во нашите напори за програмирање.</p>\n\n<p>Многу, многу, многу веб страни се достапни за да ги прашаш за одредени информации. На пример,\nследниот линк ќе ти ги даде сите моментални <a href=\"http://news.google.com/news/section?q=ruby&output=rss\" target=\"_blank\">новости на Google</a> поврзани со Ruby.</p>\n\n<p>Твојот веб прелистувач најверојатно ќе ти ги прикаже во средена верзија за тебе. \nАко погледнеш во изворот (type: control-U)\nќе видиш долг стринг формиран од чудни карактери. Примерот на Google е во <strong>rss</strong> формат.</p>\n\n<h3>Формати</h3>\n\n<p>Има многу други формати, со чудни имиња, кои се достапни и се користат на веб, како:\nhtml, xml и json. Да, дури и оваа веб страна користи некои од нив.</p>\n\n<p>Подготвив метод за тебе кој, ќе земе и ќе достави низа со комплетната работа на \nВилијам Шекспир од интернет.\n(Не грижи се, најверојатно доаѓа од истиот сервер на кој што оваа веб страна работи, \nпа така не досадуваме на никого.)</p>\n\n<p>Преземи ги податоците со следната команда:</p>\n\n<pre><code>get_shakey\n</code></pre>\n","load_code":"def get_shakey;JSON.parse(\"{\\\"William Shakespeare\\\": {\\\"1\\\": {\\\"title\\\": \\\"The Two Gentlemen of Verona\\\", \\\"finished\\\": 1591},\\\"2\\\": {\\\"title\\\": \\\"The Taming of the Shrew\\\", \\\"finished\\\": 1591},\\\"3\\\": {\\\"title\\\": \\\"Henry VI, Part 2\\\", \\\"finished\\\": 1591},\\\"4\\\": {\\\"title\\\": \\\"Henry VI, Part 3\\\", \\\"finished\\\": 1591},\\\"5\\\": {\\\"title\\\": \\\"Henry VI, Part 1\\\", \\\"finished\\\": 1592},\\\"6\\\": {\\\"title\\\": \\\"Titus Andronicus\\\", \\\"finished\\\": 1592},\\\"7\\\": {\\\"title\\\": \\\"Richard III\\\", \\\"finished\\\": 1593},\\\"8\\\": {\\\"title\\\": \\\"Edward III\\\", \\\"finished\\\": 1593},\\\"9\\\": {\\\"title\\\": \\\"The Comedy of Errors\\\", \\\"finished\\\": 1594},\\\"10\\\": {\\\"title\\\": \\\"Love's Labour's Lost\\\", \\\"finished\\\": 1595},\\\"11\\\": {\\\"title\\\": \\\"Love's Labour's Won\\\", \\\"finished\\\": 1596},\\\"12\\\": {\\\"title\\\": \\\"Richard II\\\", \\\"finished\\\": 1595},\\\"13\\\": {\\\"title\\\": \\\"Romeo and Juliet\\\", \\\"finished\\\": 1595},\\\"14\\\": {\\\"title\\\": \\\"A Midsummer Night's Dream\\\", \\\"finished\\\": 1595},\\\"15\\\": {\\\"title\\\": \\\"King John\\\", \\\"finished\\\": 1596},\\\"16\\\": {\\\"title\\\": \\\"The Merchant of Venice\\\", \\\"finished\\\": 1597},\\\"17\\\": {\\\"title\\\": \\\"Henry IV, Part 1\\\", \\\"finished\\\": 1597},\\\"18\\\": {\\\"title\\\": \\\"The Merry Wives of Windsor\\\", \\\"finished\\\": 1597},\\\"19\\\": {\\\"title\\\": \\\"Henry IV, Part 2\\\", \\\"finished\\\": 1598},\\\"20\\\": {\\\"title\\\": \\\"Much Ado About Nothing\\\", \\\"finished\\\": 1599},\\\"21\\\": {\\\"title\\\": \\\"Henry V\\\", \\\"finished\\\": 1599},\\\"22\\\": {\\\"title\\\": \\\"Julius Caesar\\\", \\\"finished\\\": 1599},\\\"23\\\": {\\\"title\\\": \\\"As You Like It\\\", \\\"finished\\\": 1600},\\\"24\\\": {\\\"title\\\": \\\"Hamlet\\\", \\\"finished\\\": 1601},\\\"25\\\": {\\\"title\\\": \\\"Twelfth Night\\\", \\\"finished\\\": 1601},\\\"26\\\": {\\\"title\\\": \\\"Troilus and Cressida\\\", \\\"finished\\\": 1602},\\\"27\\\": {\\\"title\\\": \\\"Sir Thomas More\\\", \\\"finished\\\": 1604},\\\"28\\\": {\\\"title\\\": \\\"Measure for Measure\\\", \\\"finished\\\": 1604},\\\"29\\\": {\\\"title\\\": \\\"Othello\\\", \\\"finished\\\": 1604},\\\"30\\\": {\\\"title\\\": \\\"All's Well That Ends Well\\\", \\\"finished\\\": 1605},\\\"31\\\": {\\\"title\\\": \\\"King Lear\\\", \\\"finished\\\": 1606},\\\"32\\\": {\\\"title\\\": \\\"Timon of Athens\\\", \\\"finished\\\": 1606},\\\"33\\\": {\\\"title\\\": \\\"Macbeth\\\", \\\"finished\\\": 1606},\\\"34\\\": {\\\"title\\\": \\\"Antony and Cleopatra\\\", \\\"finished\\\": 1606},\\\"35\\\": {\\\"title\\\": \\\"Pericles, Prince of Tyre\\\", \\\"finished\\\": 1608},\\\"36\\\": {\\\"title\\\": \\\"Coriolanus\\\", \\\"finished\\\": 1608},\\\"37\\\": {\\\"title\\\": \\\"The Winter's Tale\\\", \\\"finished\\\": 1611},\\\"38\\\": {\\\"title\\\": \\\"Cymbeline\\\", \\\"finished\\\": 1610},\\\"39\\\": {\\\"title\\\": \\\"The Tempest\\\", \\\"finished\\\": 1611},\\\"40\\\": {\\\"title\\\": \\\"Cardenio\\\", \\\"finished\\\": 1613},\\\"41\\\": {\\\"title\\\": \\\"Henry VIII\\\", \\\"finished\\\": 1613},\\\"42\\\": {\\\"title\\\": \\\"The Two Noble Kinsmen\\\", \\\"finished\\\": 1614}}}\");end;"},
"39":{"lang":"MK","title":"Двајцата благородни земјаци","chapter":"N","answer":"^The Two Noble Kinsmen$","ok":"Ова е многу подобро","error":"","text":"<p>Супер, сега имаме низа со претстави од интернет. Оваа низа е во json формат.\nЗа наша среќа, Ruby има метод со кој ќе направиме конверзија на json податоците во hash.\nМетодот <em>get_shakey</em> веќе го направи тоа за нас.</p>\n\n<p>Бидејќи структурата на json податоците е ставена во hash, сеуште е потешка за читање.\nАјде да напишеме метод со кој ќе ги прикажеме претставите во читлив формат.</p>\n\n<p>Доколку направиш инспекција на низата од претстави, ќе забележиш дека има вградена структура.\n(Ова всушност е многу честа појава кај податоци кои ги преземаш од интернет.)\nИзгледа како во примерот:</p>\n\n<ul>\n  <li>&ldquo;William Shakespeare&rdquo;\n  <ul>\n      <li>&ldquo;1&rdquo;\n      <ul>\n        <li>&ldquo;title&rdquo;: &ldquo;The Two Gentlemen of Verona&rdquo;</li>\n        <li>&ldquo;finished&rdquo;: 1591</li>\n      </ul>\n      </li>\n      <li>&ldquo;2&rdquo;\n      <ul>\n        <li>&ldquo;title&rdquo;: &ldquo;The Taming of the Shrew&rdquo;</li>\n        <li>&ldquo;finished&rdquo;: 1591</li>\n      </ul>\n      </li>\n      <li>&hellip;</li>\n  </ul>\n  </li>\n</ul>\n\n<p>Со цел да ги прикажеме претставите, прво треба да пристапиме до најгорниот hash елемент &ldquo;William Shakespeare&rdquo; преку неговото име.\nПотоа треба да <strong>поминеме</strong> низ секој елемент под него.</p>\n\n<p>Ruby има метод за повторување. Се вика <strong>each</strong>. Овој метод го сретнавме кога креиравме\nсопствен рејтинг систем за книги.</p>\n\n<p>Сѐ што методот <strong>each</strong> враќа се испраќа во блок:</p>\n\n<pre><code>s = get_shakey\n\ns[&quot;William Shakespeare&quot;].each { |key, val|\n  puts val[&quot;title&quot;]\n}\n</code></pre>\n","load_code":"prev"},
"40":{"lang":"MK","title":"Сите заедно сега","chapter":"N","answer":"^4$","ok":"Да, Шекспир напишал 4 претстави во 1591","error":"Одговорот за годината 1591 треба да биде 4","text":"<p>Сега претпостави дека сакаме да ги знаеме имињата и бројот на претстави напишани\nод Шекспир само за одредена година.</p>\n\n<p>Ruby ни дозволува да <strong>селектираме</strong> вредности од hash. Методот select користи блок преку кој\nни дозволува да дефинираме што сакаме да селектираме и ни го враќа она што го пронашол.</p>\n\n<p>Потоа, може да го искористиме резултатот добиен од <strong>select</strong>  методот во <strong>each</strong> методот (како претходно) со тоа што ќе го додадеме после select блокот. Ова е друг пример за поврзување на методи,\nкој го сретнавме претходно кога ја прикажувавме поемата во обратен редослед.</p>\n\n<p>Го подготвив методот <strong>count_plays</strong> за тебе. Пробај да видиш дали можеш да најдеш колку претстави\nсе напишани од Шекспир во годината <strong>1591</strong>. Пробај го следново:</p>\n\n<pre><code>def count_plays(year)\n  s = get_shakey\n\n  s[&quot;William Shakespeare&quot;]\n    .select { |k, v|\n      v[&quot;finished&quot;] == year\n    }.each { |key, val|\n      puts val[&quot;title&quot;]\n    }.count\nend\n\nputs count_plays(0)\n</code></pre>\n\n<p>Дали забележа дека го поврзав count методот на крајот на секој each метод. Ова ни ја враќа\nвредноста од <em>count_plays</em>_ методот.</p>\n\n<p>Тука, има и друга можност за поврзување на методи. Ја гледаш таа осамена линија код <strong>s = get_shakey</strong>.\nМожеш да додадеш <strong>[&ldquo;William Shakespeare&rdquo;].select { |k, v|</strong> на крајот од get_shakey\n(не е потребно за овој случај).</p>\n","load_code":"prev"},
"41":{"lang":"MK","title":"Сѐ е добро штом добро ќе заврши","chapter":"N","answer":"All's Well That Ends Well","ok":"True","error":"Стави 1605 како втор параметар","text":"<p>Добро, имаме податоци од интернет, селектиравме што сакавме и ги прикажавме резултатите.\nШто остана за подобрување? Може да ги прикажеме резултатите во подобра верзија. Како на пример\nда ја додадеме годината и да ги израмнеме насловите и годините.</p>\n\n<p>Тоа значи прикажување на неколку вредности во една линија. Ruby има елегантен начин\nза тоа. Тоа е исто како прикажување на стринг: <strong>puts &ldquo;Hi, my name is Jimmy&rdquo;</strong>.\nНо, наместо да ја користиме буквалната вредност <em>Jimmy</em>, ние ќе ја користиме вредноста на променливата.</p>\n\n<p>Прво, замени го <strong>Jimmy</strong> со <strong>#{}</strong>. Ако Ruby забележи дека имаш hash симбол проследен со { } наводници\n{ бара променлива која се наоѓа меѓу отворената заграда и затворената заграда }.\nТака, може да се искористи следното: <strong>&ldquo;Hi, my name is #{name}&rdquo;</strong>.</p>\n\n<p>Ајде малку да го промениме кодот</p>\n\n<pre><code>def print_plays(year_from, year_to)\n  get_shakey[&quot;William Shakespeare&quot;]\n    .select { |k, v|\n    year_from &lt;= v[&quot;finished&quot;] &amp;&amp;\n    year_to   &gt;= v[&quot;finished&quot;]\n  }.each { |k, v|\n    puts &quot;#{v[&quot;title&quot;].ljust(30)} #{v[&quot;finished&quot;]}&quot;\n  }\nend\nprint_plays(1600, 1605)\n</code></pre>\n\n<p>Додадов <strong>.ljust(30)</strong> на насловот. На овој начин, насловот е порамент од лева страна (анг. <em>left justified</em>) со минимум 30 карактери\nза годината да се порамни убаво.</p>\n\n<p>Значи, пробај да видиш дали ќе можеш да го промениш аутпутот на програмата за да ја прикаже претставата како во примерот:\n<strong>1600 -&gt; As You Like It</strong></p>\n\n<p><strong>Сѐ е добро штом добро ќе заврши?</strong> Не, сеуште не сме готови, но крајтот се гледа!</p>\n","load_code":"prev"},
"42":{"lang":"МК","title":"Кога само би знаел како да донесам одлука","chapter":"N","answer":"","ok":"","error":"","text":"<p>Донесувањето на одлуки (анг. decision making) во реалниот живот може да биде вистински проблем. Но не и за нас.\nRuby значително го олеснува донесувањето на одлуки.</p>\n\n<pre><code>if 1 &lt; 2\n  puts &quot;Тоа е точно: 1 е помал од 2&quot;\nend\n</code></pre>\n\n<p>Тука, резервираниот збор е <strong>if</strong>. Овој збор може да биде ставен пред некој метод или после него, како на следниов пример:</p>\n\n<pre><code>puts &quot;Тоа е точно: 1 е помал од 2&quot; if 1 &lt; 2\n</code></pre>\n\n<p><strong>If</strong> е метод кој бара еден параметар. Тој параметар може да биде било кој услов што сакаш да го тестираш. Резултатот од условот мора да биде или <strong>true</strong> или <strong>false</strong>.\nТука имаме неколку примери на услови и нивните резултати:</p>\n\n<pre><code>5     &lt;= 10     # =&gt; true\n&#39;abc&#39; == &#39;def&#39;  # =&gt; false\ntrue            # =&gt; true\n123456          # =&gt; true\n0               # =&gt; true\nnil             # =&gt; false\n&#39;xyz&#39;.empty?    # =&gt; false\n&#39;a&#39; &gt; 5         # =&gt; error:\n                # компарацијата на Стринг со\n                # Број (анг. Numeric) не успеа\n</code></pre>\n\n<p><em>if</em> условот може да има повеќе форми. Може да врши споредба на буквални вредности (1 &lt; 2),\nпроменливи (a &lt; 1) и на повратна вредност од метод (&lsquo;xyz&rsquo;.empty?).</p>\n","load_code":""},
"43":{"lang":"МК","title":"И сега, зачудувачкиот крај","chapter":"N","answer":"не е еднакво на 100$","ok":"Тоа е супер!","error":"Ова не може да биде точно","text":"<p>Дали ги виде двата знаци за еднакво во изразот <strong>&lsquo;abc&rsquo; == &lsquo;def&rsquo;</strong>?</p>\n\n<p>Овој знак <strong>==</strong> значи: <em>е еднакво на</em> (анг. <strong>is equal to</strong>).\nДодека, еден знак за еднакво, што го сретнавме и претходно, значи доделување вредност на променлива (анг. <strong>assign a value to a variable</strong>).</p>\n\n<p>За да биде уште позбунувачки, доделувањето на вредност може да се изврши и после if метод, како на пример:</p>\n\n<pre><code>a = 0\n\nif a = 100\n  puts &quot;Изразот е точен, но променливата a сега е: #{a}&quot;\nelse\n  puts &quot;#{a} не е еднакво на 100&quot;\nend\n</code></pre>\n\n<p>Знакот за еднакво = промени го во == и види што ќе се случи.</p>\n\n<p>Ти гарантирам дека често ќе забораваш да додадеш и втор знак за еднакво. И јас го заборавам понекогаш.</p>\n\n<h3>else</h3>\n\n<p>Во кодот погоре јас додадов и else израз. Овој дел ќе се изврши кога резултатот од\n<strong>if тест-изразот</strong> ќе биде неточен, односно false.</p>\n\n<blockquote>\n<p>Има повеќе варијации на if-then-else тема. Можеш да прочиташ повеќе\n<a href=\"http://www.ruby-doc.org/core/doc/syntax/control_expressions_rdoc.html\" target=\"_blank\">тука</a>.</p>\n</blockquote>\n","load_code":""},
"44":{"lang":"МК","title":"Јас гладен","chapter":"N","answer":"^Јас не гладен","ok":"Yes","error":"Нема шанси да сум гладен во 10 часот наутро!","text":"<p>Во ред, сѐ се вклопува одлично. Ова се едноставни работи за тебе, но запомни дека пред само 15 минути <strong>немаше појма за Ruby</strong>!</p>\n\n<p>Последен чекор. Ајде да сврземе сѐ заедно, може?</p>\n\n<p>Прво ќе дефинираме два методи, а потоа ќе донесеме одлука:</p>\n\n<pre><code>def hungry?(time_of_day_in_hours)\n  puts &quot;Me hungry&quot;\n  true\nend\n\ndef eat_an(what)\n  puts &quot;Me eat #{what}\\n&quot;\nend\n\neat_an &#39;apple&#39; if hungry?(14)\n\neat_an &#39;apple&#39; if hungry?(10)\n</code></pre>\n\n<p>Сега, пробај да го смениш методот <strong>hungry?</strong> да прикаже <strong>&ldquo;Јас не гладен&rdquo;</strong> и да врати false кога времето е порано од 12 часот.</p>\n","load_code":""},
"45":{"lang":"МК","title":"Резиме #6, што значи дека дојде многу далеку","chapter":"Y","answer":"\\{\\}","ok":"Во ред, тоа е празен hash","error":"","text":"<p>Ти си на 6то ниво од Ruby туторијалот. Прекрасна работа заврши. Ајде да видиме:</p>\n\n<h3>Data</h3>\n\n<p>Вчита (анг. loading) податоци од интернет, разгледа структура на податоци (анг. data structure) и направи манипулација со избрани вредности.</p>\n\n<h3>Iterating</h3>\n\n<p>Ти минуваше (анг. iterating) низ сите елементи во hash-от и поврза некои методи.</p>\n\n<h3>Прикажување текст то читлива форма (анг. pretty printing)</h3>\n\n<p>И тоа не е сѐ, ти форматираше и прикажа вредности на начин кој е лесен за читање. Всушност, <strong>ти направи вистинска програма!</strong></p>\n\n<h3>If</h3>\n\n<p>Научи како да ја контролираш твојата програма со <strong>if</strong> и <strong>else</strong> изрази.</p>\n\n<h2>Па..</h2>\n\n<p>Па, што може да биде следно? Што може да се научи сега?\nОва е најдобриот дел. Ти помина толку голем пат, што ние ќе те запознаеме со Класи. Уште две кратки лекции и ти си готов!</p>\n\n<p>Претходно, ние креиравме hash како на примерот:</p>\n\n<pre><code>Hash.new\n</code></pre>\n","load_code":""},
"46":{"lang":"МК","title":"Not a School Class, a Working Class","chapter":"N","answer":"","ok":"","error":"","text":"<p>Како што виде, празните загради {} се кратенка за Hash.new. Методот <em>new</em> се користи за инстанцирање објекти\nод одредена класа (анг. Class). Размислувај за „класа“ како на „работничка класа“ &mdash; специфична група објекти кои \nсе слични меѓу себе, имаат иста работа, исти маици.\nОд каква корист е класата?</p>\n\n<h3>Blurbalizer<sup>TM</sup></h3>\n\n<p>Ти само што добри брилијантна идеја за нова апликација. Тоа ќе биде следната инстант платформа за пораки.\nТи сакаш апликација каде луѓето можат да си праќаат едни на други кратки пораки. Овие пораки \nќе ги наречеме Blurbs<sup>TM</sup>. Еден Blurb<sup>TM</sup> ќе има максимална должина од само 40 карактери. \nИсто така ќе направиме перформанс за расположение (анг. mood setting). </p>\n\n<!---The Internet has really brought back stick people and smileys out of bankruptcy. __Emote!__-->\n\n<h3>Од каде да започнеш</h3>\n\n<p>Па, една опција е твоите Blurbs<sup>TM</sup> елементи да ги ставиш во json фајл, нели?\nНо, како ќе водиш евиденција за содржината од елементот и времето кога е постиран?\nИ кога ќе го вчиташ фајлот, како ќе изгледа во Ruby?\nЌе биде Hash? Или низа? Или низа од низи? Или пак нешто друго?</p>\n\n<h3>Класа (анг. Class)</h3>\n\n<p>Јас навистина мислам дека ќе сакаш да користиш класа. Ти си веќе запознаен со многу класи:\nHash, Array, String.\nАјде да креираме нова класа (која не враќа никаков резултат):</p>\n\n<pre><code>class Blurb\nend\n</code></pre>\n","load_code":""},
"47":{"lang":"МК","title":"Работите кои ги сочинуваат апликациите","chapter":"N","answer":"","ok":"","error":"","text":"<p>Ти отвори нова Blurb<sup>TM</sup> класа. Од што се состои твојот елемент?\nСодржина (анг. content), се разбира. Исто така, треба да го зачуваш \nвремето (анг. time) кога Blurb<sup>TM</sup> е креиран. И, расположение (анг. mood).</p>\n\n<p>Во ред, веќе ја имаш првата линија код од класата, еве го остатокот:</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\nend\n</code></pre>\n\n<p>Името на класата секогаш започнува го голема буква.</p>\n\n<p>(Сеуште немаме резултат)</p>\n","load_code":""},
"48":{"lang":"МК","title":"Accessors може да се споредат со екстремитетите на човечко тело","chapter":"N","answer":"Blurb:","ok":"Мојот прв Blurb","error":"","text":"<p>Супер дефинирана класа, читателу. Ти сега имаш нова Blurb<sup>TM</sup> класа.</p>\n\n<p>При дефинирање на класата, ти користеше метод наречен attr_accessor.\nИма многу <strong>attr</strong>ibute методи како на пример методот која додава мали преференци на класата.\nОвие атрибути (анг. attributes) се само променливи прикачени за класа.</p>\n\n<p>Размислувај на овој начин. Класата е како човек. А, атрибутите се различните делови\nод кои е направено човечкото тело, како на пример рака чија една од функционалностите е \nракување со друг човек.</p>\n\n<h3>Сега</h3>\n\n<p>За да креираш Blurb<sup>TM</sup> и да ставиш содржина погледни го примерот:</p>\n\n<pre><code>blurb1 = Blurb.new\nputs blurb1\nblurb1.content = &quot;Today Mount Hood Was Stolen!&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;end"},
"49":{"lang":"МК","title":"Објект, тоа мало убаво пакување","chapter":"N","answer":"Blurb:","ok":"Blurb е ажуриран","error":"","text":"<p>Те охрабрувам да пробаш да ставиш време и расположение на  Blurb<sup>TM</sup>:</p>\n\n<pre><code>blurb1.time = Time.now\nblurb1.mood = :sick\n\nputs blurb1\n</code></pre>\n","load_code":"prev;blurb1=Blurb.new;blurb1.content=\"Today Mount Hood Was Stolen!\""},
"50":{"lang":"МК","title":"Ајде малку да забрзаме","chapter":"N","answer":"^\\d{4}","ok":"Забележано","error":"","text":"<p>Супер, твојата апликација е прекрасна. Ајде малку да ти ги олесниме работите.\nТи сигурно не сакаш да го ставаш времето на овој начин секогаш кога креираш или ажурираш Blurb<sup>TM</sup>.</p>\n\n<p>Ти само сакаш да внесеш содржина и да го поставиш расположението, нели?</p>\n\n<p>Ајде да додадеме <strong>initialize</strong> метод на нашата класа. Овој метод се повикува секогаш кога е креиран нов Blurb<sup>TM</sup>.\nВо исто време може да ставиме лимит за должината на содржината на Blurb<sup>TM</sup> да биде 40 карактери.</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\n\n  def initialize(mood, content=&quot;&quot;)\n    @time    = Time.now\n    @content = content[0..39]\n    @mood    = mood\n  end\nend\n\nBlurb.new.time\n</code></pre>\n\n<p>(Параметарот <strong>content=&ldquo;&rdquo;</strong> е тука за да нѐ потсетува дека содржината е од тип Стринг,\nиако параметер со содржина не е пуштен во initialize методот.)</p>\n","load_code":""},
"51":{"lang":"МК","title":"Ти ја научи апликацијата да ги одбива непотребните работи","chapter":"N","answer":"Blurb:","ok":"Blurb е додаден","error":"","text":"<p>Дали забележа дека внатре во класата ние користевме at-симболи (@time).</p>\n\n<p><strong>Надвор</strong> од класата, ние искористивме accessors:</p>\n\n<blockquote>\n<p><strong>blurb.time = Time.now</strong></p>\n</blockquote>\n\n<p>но, <strong>внатре</strong> ги користиме <strong>променливите од објектот</strong>:</p>\n\n<blockquote>\n<p><strong>@time = Time.now</strong></p>\n</blockquote>\n\n<p>Тие се едно исто, но прикажани на две различни места во твојата програма.</p>\n\n<h3>Креирај нов Blurb<sup>TM</sup></h3>\n\n<p>Кога нов Blurb<sup>TM</sup> е креиран, initialize методот се користи за да провери дали има нови параметри.</p>\n\n<p>Во овој случај, нам ни требаат два параметри:</p>\n\n<pre><code>Blurb2 = Blurb.new :confused, &quot;I can not believe Mt. Hood was stolen!&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end;blurb1=Blurb.new(:sick,\"Today Mount Hood Was Stolen!\")"},
"52":{"lang":"МК","title":"Жирафа не го украде Резимето #7","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Браво, успеа да стигнеш до тука. Твојата апликација ќе ја направиме да биде реална, но прво да направиме резиме, може? </p>\n\n<h3>Класи</h3>\n\n<p>Сѐ во Ruby е некаков вид на објект. Класите ги објаснуваат објектите, односно како тие функционираат.\nНа пример, ти направи неколку Blurb<sup>TM</sup> објекти и тие се објаснети во Blurb класата.\nСо други зборови: ние ги викаме Blurb објекти.\nМожеш да ги користиш класите за (речиси) да моделираш објекти од реалниот свет.</p>\n\n<h3>Accessors</h3>\n\n<p>Accessors се променливи прикачени на објект кои можат да се користат <strong>надвор</strong> од објектот.\n(blurb2.time = Time.now)</p>\n\n<h3>Објект променливи</h3>\n\n<p>Објект променливи се истите променливи што ти ги користиш како accessors, но <strong>внатре</strong> во самиот објект.\n(@time = Time.now)</p>\n","load_code":"prev;blurb2=Blurb.new :confused, \"I can not believe Mt. Hood was stolen!\""},
"53":{"lang":"МК","title":"Твојата сопствена територија","chapter":"N","answer":"Blurbalizer:","ok":"myapp е креирана","error":"","text":"<p>Тука може да ги привршуваме работите, читателу. Тука е последното поглавје од епската приказна на TryRuby!\nСега кога имаш ориентација како сѐ работи, како ќе ги искористиш за твојата куќа и за твојот замрзнувач? \nТи си прекрасна личност, дури и една од моите омилени, но сепак ти треба насочување.</p>\n\n<h3>Ајде да ја завршиме твојата апликација</h3>\n\n<p>Ти имаш елементи, но немаш вистинска програма.\nСеуште треба наслов, некое место за да ги зачуваме сите Blurbs<sup>TM</sup> и времеплов (анг. timeline) со цел да функционира.</p>\n\n<p>Погоди што? Ние ќе користиме уште една класа. Во следниот пример е прикажан целиот код од новата класа во една целина.\nДозволи си онолку време колку што ти треба за да го проучиш.\nЈас не сум во брзање, ќе те причекам во следната лекција. </p>\n\n<pre><code>class Blurbalizer\n  def initialize(title)\n    @title  = title\n    @blurbs = [] # Нова празна низа \n                 # за зачувување Blurbs\n  end\n\n  def add_a_blurb(mood, content)\n    # Овој знак &lt;&lt; значи додај го елементот на крајот од низата\n    @blurbs &lt;&lt; Blurb.new(mood, content)\n  end\n\n  def show_timeline\n    puts &quot;Blurbify: #{@title} has #{@blurbs.count} Blurbs&quot;\n\n    @blurbs.sort_by { |t|\n      t.time\n    }.reverse.each { |t|\n      puts &quot;#{t.content.ljust(40)} #{t.time}&quot;\n    }\n  end\nend\n\nmyapp = Blurbalizer.new &quot;The Big Blurb&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end"},
"54":{"lang":"МК","title":"Што се работи во Blurb?","chapter":"N","answer":"Today","ok":"Bring on the blurbs","error":"","text":"<p>Одлично, пристина до уште една нова лекција! Дали сфати што прави кодот во  Blurbalizer<sup>TM</sup> класата?</p>\n\n<blockquote>\n<p>Во Blurbalizer<sup>TM</sup> има два <strong>методи</strong> (add_a_blurb and show_timeline).\nТи можеш да користиш метод надвор од класата, на ист начин како што направивме со accessors.</p>\n</blockquote>\n\n<p>Време е да почнеме да ја користиме Blurbalizer<sup>TM</sup>. Јас веќе вчитав (анг. loaded) неколку \nBlurbs<sup>TM</sup> за тебе, но чувствувај се слободно да додадеш твои нови.</p>\n\n<p>Ние сега не креираме Blurbs<sup>TM</sup> директно, туку користиме add_a_blurb <strong>метод</strong> од \nBlurbalizer<sup>TM</sup> класата. На овој начин, може да се осигураме дека сите наши Blurbs<sup>TM</sup>\nсе зачувани во myapp објектот.</p>\n\n<pre><code>myapp.add_a_blurb :moody, &quot;Додај Blurb тука&quot;\n\nmyapp.show_timeline\n</code></pre>\n","load_code":"prev;class Blurbalizer;attr_reader :title;def initialize(title);@title=title;@blurbs=[];end;def add_a_blurb(mood, content);@blurbs << Blurb.new(mood, content);@blurbs.each {|t| t.time -= 73};end;def show_timeline;puts \"Blurbalizer: #{@title} has #{@blurbs.count} Blurbs\\n\";@blurbs.sort_by { |t| t.time}.reverse.each { |t| puts \"#{t.content.ljust(40)} #{t.time}\"};end;end;myapp = Blurbalizer.new \"The Big Blurb\";myapp.add_a_blurb :sick,\"Today Mount Hood Was Stolen!\";myapp.add_a_blurb :confused,\"I can not believe Mt. Hood was stolen!\";myapp.add_a_blurb :dazed,\"I am speechless!\";myapp.add_a_blurb :mad,\"It was stolen by a giraffe !!\";myapp.add_a_blurb :sad,\"I Left my Hoodie on the Mountain!\";myapp.add_a_blurb :mad,\"I am never going back to that mountain.\""},
"55":{"lang":"МК","title":"Сѐ е до комбинирањето","chapter":"N","answer":":-","ok":"Moody!","error":"","text":"<p>Некои убави работи можат да бидат направени со едноставни делови од Ruby, посебно кога ќе ги\nискомбинираш заедно за да креираш нови работи.</p>\n\n<p>Тука, ние имаме апликација направена од класа која содржи друга класа. И, всушност, Ruby навистина добро\nфункционира со ваквите вгнездувања. Тоа се нарекува објектно ориентирано програмирање.</p>\n\n<p>Ние стигнавме до <strong>последната вежба за програмирање</strong> од TryRuby. Доколку сакаш, можеш да додадеш\nи други карактеристики (анг. features) на Blurbalizer<sup>TM</sup>.</p>\n\n<p>Можеби ти сакаш да го прикажеш расположението преку емотикони во <strong>show_timeline</strong> методот. Можеш \nда додадеш <em>moodify</em> во Blurb<sup>TM</sup> класата и тогаш да го искористиш тој метод во \n <em>show_timeline</em> методот:</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\n\n  def initialize(mood, content=&quot;&quot;)\n    @time    = Time.now\n    @content = content[0..39]\n    @mood    = mood\n  end\n\n  def moodify\n    if    @mood == :sad\n      return &quot;:-(&quot;\n    elsif @mood == :happy\n      return &quot;:-)&quot;\n    # Add other moods here\n    end\n\n    # The default mood\n    &quot;:-|&quot;\n  end\nend\n\nclass Blurbalizer\n  def initialize(title)\n    @title  = title\n    @blurbs = []\n  end\n\n  def add_a_blurb(mood, content)\n    @blurbs &lt;&lt; Blurb.new(mood, content)\n  end\n\n  def show_timeline\n    puts &quot;Blurbalizer: #{@title} has #{@blurbs.count} Blurbs&quot;\n\n    @blurbs.sort_by { |t|\n      t.time\n    }.reverse.each { |t|\n      puts &quot;#{t.content.ljust(40)} #{t.time}&quot;\n    }\n  end\nend\n\nmyapp.show_timeline\n</code></pre>\n","load_code":"prev"},
"56":{"lang":"МК","title":"Резиме #8, или опушти-се-издржа","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Оваа последна лекција ја искористивме малку да забавиме и да потенцираме неколку работи како ти\nможеш да го користиш Ruby програмскиот јазик.</p>\n\n<p>Доколку уживаше, можеш да продолжиш со <a href=\"/playground\">TryRuby Playground</a>\nили преземи го и инсталирај Ruby:\n<a href=\"https://www.ruby-lang.org/en/downloads/\" target=\"_blank\">ruby-lang.org</a></p>\n\n<p>Штом ќе завршиш со инсталација на Ruby, можеш да креираш фајл, на пример <em>my_first_progam.rb</em>,\nво текст едитор каде ќе напишеш Ruby код. Потоа кодот ќе го извршиш со отворање на терминал (или командна линија) и пишување\nна следнава команда:</p>\n\n<pre><code>ruby my_first_progam.rb\n</code></pre>\n\n<p>Има многу (бесплатни) алатки за развој на софтвер (анг. software development) кои се комбинираат во едитор, file browser и &lsquo;ruby-runner&rsquo;.</p>\n\n<h2>Прослави</h2>\n\n<p>Ти навистина заслужи двослојна торта со двослоен прелив и некој да ти засвири на гитара.\nТи ги совлада сите делови од овој туторијал! Нема сомнеж за тоа, ти си сега <strong>certified red-blooded smartiac!</strong></p>\n\n<h2>Нешто повеќе</h2>\n\n<p>Има повеќе статии на оваа веб страна. Таму ќе добиеш насоки каде да продолжиш да се\nдвижиш штом завршиш тука.</p>\n","load_code":"def ruby(f);puts \"Go to www.ruby-lang.org to download Ruby\";end;class K;attr_reader :rb;end;my_first_progam=K.new"}}