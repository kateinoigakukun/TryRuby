{"1":{"lang":"RU","title":"Есть 30 минут? Дай Ruby шанс, и он тебя удивит!","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Ruby - это язык программирования из Японии, который произвел революцию в веб-разработке.</p>\n\n<p>Прелесть Ruby в балансе между простотой и возможностями.</p>\n\n<p>Ты можешь ввести код на Ruby в редакторе и использовать кнопки для навигации:</p>\n\n<ul>\n<li><strong>Run</strong> &rarr; Выполнить код, находящийся в редакторе</li>\n<li><strong>Copy</strong> &rarr; Вставить/скопировать пример кода в редактор</li>\n<li><strong>Next</strong> &rarr; Перейти к следующему уроку</li>\n<li><strong>Back</strong> &rarr; Вернуться к предыдущему уроку</li>\n</ul>\n\n<div class=\"foxes\">Нажми <strong>Next</strong> для начала обучения.</div>\n","load_code":""},
"2":{"lang":"RU","title":"Использование редактора","chapter":"N","answer":"^\\d{1,}$","ok":"Отлично! Вы немного попрактиковались в математике.<br/>Видите полученный результат?","error":"Наберите 2 + 6 в редакторе","text":"<p>Набирайте свой код на Ruby в окне редактора снизу, затем нажмите кнопку <strong>Run</strong> и посмотрите его работу!</p>\n\n<p>Например, попробуем посчитать простое выражение:</p>\n\n<pre><code>2 + 6\n</code></pre>\n\n<p>Результат вашей программы должен отображаться в окне вывода вверху.\nНа следующей строке будет отображаться, настолько хорошо Вы справились.</p>\n\n<blockquote>\n<p>Также Вы можете нажать кнопку <strong>Copy</strong>, чтобы скопировать код из примера в редактор.</p>\n</blockquote>\n","load_code":""},
"3":{"lang":"RU","title":"Числа и математика","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Хорошо!","error":"","text":"<p>Ruby понимает числа и математические операции. Попробуйте их использовать, как в примере:</p>\n\n<pre><code>4 * 10\n5 - 12\n30 / 4\n</code></pre>\n","load_code":""},
"4":{"lang":"RU","title":"Выводим результат иначе","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Отлично!","error":"","text":"<p>Вы заметили, что если Вы набираете более одного выражения, выводится результат только последнего.\nЧто же происходит?</p>\n\n<blockquote>\n<p>Для более удобного использования этого сайта, я указал Ruby копировать результат вашей программы\nв поле вывода вверху. Так когда Вы набираете выражение, результат выводится на экран.\n<strong>Но только последний результат.</strong> И только если до этого ничего не выводилось</p>\n</blockquote>\n\n<p>Так когда Вы вводите несколько выражений, Ruby показывает результат только последнего</p>\n\n<p>Конечно, Вам хочется увидеть результат всех! Добавьте <strong>puts</strong> перед каждым выражением\n(разделяя пробелом). Puts означает: <em>&lsquo;вывести что-то на экран&rsquo;</em>.</p>\n\n<p>Попробуйте:</p>\n\n<pre><code>puts 4 * 10\nputs 5 - 12\nputs 30 / 4\n</code></pre>\n\n<p>А теперь удалите <strong>puts</strong> из последней формулы и посмотрите, что произойдет.</p>\n","load_code":""},
"5":{"lang":"RU","title":"Скажи свое имя!","chapter":"N","answer":"[a-zA-Zа-яА-Я]{1,1}","ok":"Отлично, Вы сформировали строку из букв Вашего имени.","error":"","text":"<p>Конечно, компьютеры удобны для расчетов. Но давайте попробуем что-то еще. А хотите вывести свое имя задом наперед?</p>\n\n<p>Для начала наберите свое имя в кавычках как тут:</p>\n\n<pre><code>&quot;Иван&quot;\n</code></pre>\n","load_code":""},
"6":{"lang":"RU","title":"Скажи свое имя наоборот","chapter":"N","answer":".+","ok":"!отурК","error":"","text":"<p>Строка представляет собой набор символов, которые компьютер может обрабатывать. Представьте, что буквы, находящиеся в строке, - это \nбелье на верёвке, а кавычки - прищепки, держащие концы этой веревки. Кавычки обозначают начало и конец.</p>\n\n<p>Чтобы получить имя задом наперед, наберите: </p>\n\n<pre><code>&quot;Ivan&quot;.reverse\n</code></pre>\n\n<p>(И не забудьте про точку!)</p>\n","load_code":""},
"7":{"lang":"RU","title":"Подсчет букв","chapter":"N","answer":"^\\d+$","ok":"Ага! length - это тоже метод!","error":"","text":"<p>Вы уже попробовали использовать <strong>method</strong> reverse на своем имени! Заключив имя в кавычки, Вы создали строку. Затем Вы вызвали метод reverse, который работает со строками и разворачивает ее задом наперед.</p>\n\n<p>А теперь давайте посмотрим, сколько букв в Вашем имени:</p>\n\n<pre><code>&quot;Ivan&quot;.length\n</code></pre>\n","load_code":""},
"8":{"lang":"RU","title":"На повторе","chapter":"N","answer":"(.+)","ok":"Рад Вас видеть. Рад Вас видеть. Рад Вас видеть.","error":"adfadsfadsf","text":"<p>Сейчас Вам, наверное, интересно, зачем это нужно.</p>\n\n<p>Что ж, я уверен, Вы хоть раз замечали на сайте надпись: <strong>Эй, твой пароль слишком короткий!</strong></p>\n\n<p>Смотрите, некоторые программы используют код <strong>.length</strong>.</p>\n\n<p>А теперь рассмотрим это. Давайте выведем Ваше имя 5 раз</p>\n\n<pre><code>&quot;Ivan&quot; * 5\n</code></pre>\n","load_code":""},
"9":{"lang":"RU","title":"Подводим итоги #1 Уже","chapter":"Y","answer":"NoMethodError|undefined","ok":"Неа, нельзя использовать метод reverse с числом. Жми 'next'","error":"","text":"<p>Давайте посмотрим, что Вы уже изучили.</p>\n\n<h3>Редактор кода</h3>\n\n<p>Можно набирать код в редакторе и получать ответ в окне вывода.\nБольшинство программ выдают ответ.</p>\n\n<h3>Числа и строки</h3>\n\n<p>Числа и строки это математические и текстовые объекты в Ruby.</p>\n\n<h3>Методы</h3>\n\n<p>Вы попробовали использовать методы из слов на английском языке reverse и length. А также символьный\nметод умножения: *<br>\n<strong>Метод значит действие!</strong></p>\n\n<p>В этом суть Вашего обучения. Берем базовые вещи, играем с ними и превращаем их в\nнечто новое. Понравилось? Я надеюсь, что да!</p>\n\n<h2>Хорошо</h2>\n\n<p>А давайте попробуем кое-что необычное. Попробуйте применить метод reverse к числу:</p>\n\n<pre><code>40.reverse\n</code></pre>\n","load_code":""},
"10":{"lang":"RU","title":"Остановись, ты сумасшедший!","chapter":"N","answer":"^\\d{1,}$","ok":"Только строки могут быть развернуты задом наперед","error":"","text":"<p>Ты не можешь развернуть число задом наперед.  Я думаю, Вы, конечно можете держать монитор перед зеркалом, но разворачивание числа просто не имеет смысла.</p>\n\n<p>Ruby выведет сообщение с ошибкой. Ruby говорит Вам, что не существует метода reverse для чисел.</p>\n\n<p>Но можно попробовать преобразовать число 40 в строку для начала:</p>\n\n<pre><code>40.to_s.reverse\n</code></pre>\n","load_code":""},
"11":{"lang":"RU","title":"Яблоки отличаются от апельсинов","chapter":"N","answer":"\\[\\]","ok":"Отлично. Это пустой список.","error":"","text":"<p>И числа отличаются от строк.</p>\n\n<p>В то время как использование методов применимо ко всем типам, некоторые методы работают только с определенными типами данных.\nНо Вы всегда можете преобразовать один тип в другой, используя методы вида &ldquo;to&rdquo;</p>\n\n<ul>\n<li><strong>to_s</strong> преобразует в строки</li>\n<li><strong>to_i</strong> преобразует в число</li>\n<li><strong>to_a</strong> преобразует в массив</li>\n</ul>\n\n<p><strong>Что такое массив?!</strong></p>\n\n<p>Массив - это всего лишь список. Наберите 2 квадратные скобки:</p>\n\n<pre><code>[]\n</code></pre>\n","load_code":""},
"12":{"lang":"RU","title":"Очередь за попкорном","chapter":"N","answer":"^\\[([-\\.\\d]+)(\\s*,\\s*[-\\d\\.]+){3,}\\]$","ok":"Прекрасно!","error":"Попробуйте добавить четвертое число в массив.","text":"<p>Списки (массивы) хранят элементы <strong>в определенной последовательности</strong>.</p>\n\n<p>Похоже на очередь за попкорном. Вы стоите за кем-то и не пытаетесь его оттолкнуть или передвинуть, верно?\nТакже человек за Вами </p>\n\n<p>Вот список для Вас. Номера лотерейных билетов: </p>\n\n<pre><code>[12, 47, 35]\n</code></pre>\n\n<p>Попробуйте добавить число в массив. Наберите запятую и число после 35. Пробел не обязательно.</p>\n","load_code":""},
"13":{"lang":"RU","title":"Первый поднимает руку","chapter":"N","answer":"^47$","ok":"Хорошо","error":"","text":"<p>Список номеров лотерейных билетов. А какой номер максимальный?</p>\n\n<p>Попробуйте: </p>\n\n<pre><code>[12, 47, 35].max\n</code></pre>\n","load_code":""},
"14":{"lang":"RU","title":"Спрячем список","chapter":"N","answer":"^\\[(\\d+)(,\\s*\\d+){2,}\\]$","ok":"Сохранено!","error":"","text":"<p>Хорошо, хорошо. Но неудобно же набирать каждый раз, когда он может понадобиться, не так ли?</p>\n\n<p>Давайте сохраним наши номера лотерейного билета вот так:</p>\n\n<pre><code>ticket = [12, 47, 35]\n</code></pre>\n","load_code":""},
"15":{"lang":"RU","title":"А теперь наберите ticket","chapter":"N","answer":"\\[(\\d+(, )?){2,}\\]","ok":"Восстановлен!","error":"","text":"<p>А сейчас наберите:</p>\n\n<pre><code>ticket\n</code></pre>\n","load_code":"ticket = [12, 47, 35]"},
"16":{"lang":"RU","title":"Сохранен и спрятан","chapter":"N","answer":"\\[12, 35, 47\\]","ok":"Вы отсортировали список!","error":"","text":"<p>Вы положили список номеров в <strong>переменную</strong>, называющуюся ticket.\nНо любое другое имя, такое как <em>ivanslist</em>, по-прежнему свободно.</p>\n\n<p>Занимаясь программированием, Вы заметите, что основная работа связана с переменными</p>\n\n<p>А давайте упорядочим список лотерейных билетов?</p>\n\n<p>Используйте: </p>\n\n<pre><code>ticket.sort!\n</code></pre>\n\n<p>У Вас есть список. Вы отсортировали список. Переменная ticket изменилась.\nА Вы заметили, что у метода <strong>sort!</strong> на конце стоит восклицательный знак?\nТак Ruby сообщает нам, что переменная ticket будет изменена.\nНичего необычного, просто запомните!</p>\n","load_code":"ticket = [12, 47, 35]"},
"17":{"lang":"RU","title":"Элементы","chapter":"N","answer":"^(12|35|47)$","ok":"Хорошо","error":"Почти","text":"<p>Мы сохранили номера в переменную, а как их получить обратно ?</p>\n\n<p>Мы уже видели, как мы можем получить максимальный элемент, используя метод <strong>max</strong>. Также Вы можете\nполучить <strong>first</strong>(первый) или <strong>last</strong>(последний) элемент списка.\nА что если Вы хотите получить какой-то конкретный элемент?</p>\n\n<h3>[ ]</h3>\n\n<p>Ruby использует [ ], чтобы нацелиться на элемент.\nКвадратные скобки очень распространены в Ruby.\nОни означают: &ldquo;Я ищу ____ &rdquo;, Готов, целься! </p>\n\n<p>Давайте получим все номера из списка:</p>\n\n<pre><code>puts ticket[0]\nputs ticket[1]\nputs ticket[2]\n</code></pre>\n\n<p>Почему мы используем [0], [1], [2]?</p>\n\n<p>А не [1], [2] and [3]? Это какой-то японский дзен?\nНет, во многих языках программирования отсчет идет с нуля. Это не только особенность Ruby.</p>\n\n<blockquote>\n<p>Небольшое напоминание: Вы можете использовать кнопку copy.</p>\n</blockquote>\n","load_code":"ticket = [12, 47, 35]"},
"18":{"lang":"RU","title":"Итоги #2 Что тут у нас?","chapter":"Y","answer":"(.+)","ok":"В рифму?","error":"","text":"<p>Сейчас посмотрим.</p>\n\n<h3>Ошибки</h3>\n\n<p>Если вы попробуете сделать число наоборот или другое что-то странное, Ruby скажет об этом.</p>\n\n<h3>Массивы</h3>\n\n<p>Массивы - это списки, хранящие элементы в определенной последовательности.\nМы уже знаем, как создать массив и получить элементы из него.</p>\n\n<h3>Переменные</h3>\n\n<p>Переменные сохраняют значения и дают им имена. Мы используем символ равенства, \nчтобы проделать это. Как тут:\nticket = [14, 37, 18].</p>\n\n<h3>2/8</h3>\n\n<p>Всего тут 8 разделов. 2 уже позади! Не так-то и сложно, да?</p>\n\n<p>Давайте немного сменим направление. Я практиковался в поэзии и положил\nрезультат в переменную poem. Взгляните. Наберите:</p>\n\n<pre><code>puts poem\n</code></pre>\n","load_code":"poem = \"Мой тост вылетел из моей руки. \\nИ мой тост отправился на луну. \\nНо когда я увидел это по телевизору, \\nЗаправляя наш флаг на комету Галлея, \\nПосле того, как я все-таки захотел съесть его\\n\""},
"19":{"lang":"RU","title":"К сожалению, Вам не понравилась поэзия :(","chapter":"N","answer":"(toast){0}","ok":"Прекрасно!","error":"","text":"<p>Все в порядке. Это не обязательно должно было понравиться Вам. Попробуйте его, будьте моим гостем. Вместо тоста может быть\nпирог или что угодно. Попробуйте это, чтобы увидеть новый вариант поэмы:</p>\n\n<pre><code>poem.gsub(&quot;тост&quot;, &quot;медовик&quot;)\n</code></pre>\n\n<p>Метод <strong>gsub</strong>  это сокращение global substitute (заменитель). Он заменяет все совпадения &ldquo;тост&rdquo; на\n&ldquo;медовик&rdquo;.</p>\n","load_code":"prev"},
"20":{"lang":"RU","title":"Готов, целься!","chapter":"N","answer":"^\\nоге ьтсеъс летохаз (.+)","ok":"Конечно, все стихотворение развернуло задом наперед.","error":"","text":"<p>Вот вопрос, что произойдет:</p>\n\n<pre><code>poem.reverse\n</code></pre>\n","load_code":"prev"},
"21":{"lang":"RU","title":"Слишком много слов наоборот","chapter":"N","answer":"^\\[\"После того, как я (.+)","ok":"Да, то что нужно!","error":"","text":"<p>Что ж, все стихотворение стало задом наперед. Слово за словом! Но я хочу всего лишь сделать это для строк.\nПереместим первую строку в конец, а последнюю в начало.</p>\n\n<p>Теперь делаем так:</p>\n\n<pre><code>poem.lines.reverse\n</code></pre>\n","load_code":"prev"},
"22":{"lang":"RU","title":"Еще немного методов","chapter":"N","answer":"^После того, как я (.+)","ok":"Отлично, мой друг!<br/>Метод join взял строки из этого массива и соединил их в строку.","error":"","text":"<p>Что Вы видите? Что произошло? Вы набрали <strong>poem.lines.reverse</strong> и что случилось?</p>\n\n<p>Два события произошло. Первое: вы разбили стихотворения на строки, используя метод lines, \nи получили массив из них.</p>\n\n<p>Затем Вы развернули этот лист задом наперед. Вот и все!</p>\n\n<p>Давайте добавим еще один метод в конец:</p>\n\n<pre><code>puts poem.lines.reverse.join\n</code></pre>\n\n<p>Комбинирование методов называется: цепочка методов.</p>\n","load_code":"prev"},
"23":{"lang":"Ru","title":"Итоги #3 Здесь и сейчас","chapter":"Y","answer":"\\{\\}","ok":"Вы создали пустой hash (словарь)!","error":"","text":"<h3>Восклицательный знак</h3>\n\n<p>Методы могут иметь восклицательные знаки(и также вопросительные) в своем имени.\nОни для более понятного объяснения, что они делают. Ничего страшного.</p>\n\n<h3>Манипуляции со строками</h3>\n\n<p>Поиск и изменение строк</p>\n\n<h3>Цепочки</h3>\n\n<p>Цепочки методов позволяют сделать намного больше. Разбить стихотворение, развернуть его, воссоединить в строку:\n<strong>poem.lines.reverse.join</strong></p>\n\n<p>На этом этапе, Вы можете посмотреть про ВСЕ методы для строк <a href=\"http://ruby-doc.org/core/classes/String.html\" target=\"_blank\">тут</a>.</p>\n\n<p>Вернитесь и попробуйте например это:\npoem.downcase или poem.swapcase</p>\n\n<h2>Готовы?</h2>\n\n<p>Когда вы будете готовы двигаться дальше, наберите:</p>\n\n<pre><code>books = {}\n</code></pre>\n","load_code":"prev"},
"24":{"lang":"RU","title":"Пустой hash","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"Вот и новый отзыв.","error":"Используйте один из: splendid, quite_good, mediocre, quite_not_good, abysmal.<br/>Не забывайте про двоеточие.","text":"<p>Мы создали пустой <strong>hash</strong>. Hash - это как массив, только у каждого элемента есть имя.</p>\n\n<blockquote>\n<p>Примечание переводчика: в русскоязычном сообществе слово hash никак не переводится. Если Array переводят как массив, то Hash остается хэш.\nНазвание hash идет от hash-функции, на основе которой работает hash, и которая позволяет очень быстро находить элемент по ключу(имени). Но для того, чтобы использовать hash, нам не обязательно этого знать.</p>\n</blockquote>\n\n<p>Мы собираемся написать несколько миниатюрных отзывов в новый hash. Вот наша рейтинговая система:</p>\n\n<ul>\n<li>:splendid &rarr; ШЕДЕВР!</li>\n<li>:quite_good &rarr; Понравилась!</li>\n<li>:mediocre &rarr; На троечку!</li>\n<li>:quite_not_good &rarr; Плохо!</li>\n<li>:abysmal &rarr; УЖАСНО!</li>\n</ul>\n\n<p>Чтобы оценить книгу, добавьте название в квадратных скобках и поставьте оценку после знака равно.\nПример:</p>\n\n<pre><code>books[&quot;Война и мир&quot;] = :splendid\n</code></pre>\n\n<blockquote>\n<p>Сейчас, я считаю необходимым сказать, что все уроки в TryRuby отделены друг от друга.\nТак, если вы решили сделать очень много отзывов, то использовать их все равно сможете только в этом уроке.\nЕсли вы хотите использовать свои отзывы в следующем уроке, вы должны скопировать их и вставить.\nНе беспокойтесь об этом слишком сильно, у каждого урока есть много предопределенных вещей для вас, чтобы поиграть.</p>\n</blockquote>\n","load_code":"books = {}"},
"25":{"lang":"RU","title":"Еще несколько простых отзывов","chapter":"N","answer":"[3-9]","ok":"Отлично, смотрите: метод length работает на строках, словарях и массивах.","error":"","text":"<p>Продолжайте, заполните его отзывами. И, если вы хотите увидеть весь список, просто введите: <strong>puts books</strong></p>\n\n<p>Опять же, возможные оценки: :splendid, :quite_good, :mediocre, :quite_not_good and :abysmal.</p>\n\n<p>Эти оценки не являются строками. Когда вы помещаете двоеточие перед простым словом, вы получаете <strong>Symbol</strong>.\nSymbol дешевле строк (с точки зрения компьютерной памяти). Если вы используете слово снова и снова в своей программе,\nиспользуйте Symbol. Вместо того, чтобы иметь тысячи копий этого слова в памяти, Ruby будет хранить Symbol только\n<strong>один раз</strong>.</p>\n\n<p>Что еще более важно, Symbol говорит вам, что это не просто старое слово, но и то, что оно имеет смысл в вашей программе.</p>\n\n<blockquote>\n<p>Примечание переводчика: в английском языке есть два слова: Symbol и Chars, и оба переводятся на русский как символ(ы).<br>\nВ контексте Ruby Symbol правильно было бы перевести как &ldquo;идентификатор&rdquo;, но в разговоре используют слово символ. \nПоэтому если в контексте Ruby вы услышите &ldquo;символ&rdquo;, то скорее всего это Symbol, идентификатор, который записывается как :good, и является оптимизированной для памяти строкой</p>\n</blockquote>\n\n<p>Введите еще 2 отзыва, используйте <strong>books.length</strong>, чтобы узнать, сколько отзывов в hash:</p>\n\n<pre><code>books[&quot;The deep end&quot;]  = :abysmal\nbooks[&quot;Living colors&quot;] = :mediocre\n\nputs books\n\nputs books.length\n</code></pre>\n","load_code":"books = {\"Gravitys Rainbow\" => :splendid}"},
"26":{"lang":"RU","title":"Погодите, я не хуже Войны и мир?","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"Мне нравится","error":"","text":"<p>Одна особенность Ruby заключается в том, что имена часто используются повторно, что означает меньшее количество имен, которые вам нужно запомнить.</p>\n\n<p>Помните, как мы извлекали элементы из массива с помощью числа:\n_<em>puts ticket [1] _</em>.</p>\n\n<p>Для hash это работает одинаково, за исключением того, что мы не используем число, чтобы получить элемент, а имя(ключ, key, прим. переводчика).</p>\n\n<p>Итак, если вы хотите посмотреть один из своих старых отзывов, снова введите название в квадратных скобках. Но не пишите равенство.\nИменно так:</p>\n\n<pre><code>puts books[&quot;Война и мир&quot;]\n</code></pre>\n","load_code":"books = {\"Война и мир\" => :splendid, \"Отцы и дети\" => :abysmal, \"Идиот\" => :mediocre}"},
"27":{"lang":"RU","title":"Словари это пары","chapter":"N","answer":"^\\[\".*\"\\]","ok":"Вы нашли ключи","error":"","text":"<p>Помните, что словари не хранят элементы в последовательности. Это не их задача.\nОни создают пару: ключ(key) : значение(value) </p>\n\n<p>В ваших отзывах, название книги - это ключ, а оценка - значение.</p>\n\n<p>Если вы хотите увидеть все названия книг, введите:</p>\n\n<pre><code>books.keys\n</code></pre>\n\n<p>Также попробуйте использовать .values вместо .keys.</p>\n","load_code":"prev"},
"28":{"lang":"RU","title":"А ты суров?","chapter":"N","answer":"\"mediocre\"","ok":"Отлично, круто! Вы создали таблицу своих оценок","error":"","text":"<p>Вы выдаете суровые, несправедливые отзывы? Давайте посчитаем их в новом hash <strong>ratings</strong>:\nСледуя за мной, наберите:</p>\n\n<pre><code>ratings = Hash.new {0}\n\nbooks.values.each { |rate|\n  ratings[rate] += 1\n}\n\nputs ratings\n</code></pre>\n\n<p>Прямой линией в коде является символ pipe , вероятно, расположенный над клавишей Enter\nна клавиатуре.</p>\n\n<p>Эта строка _ + = 1_ означает: увеличить значение на 1.</p>\n\n<p>Не беспокойтесь, если вы не понимаете все, что здесь происходит. Это будет показано позже.</p>\n","load_code":"books = {\"Война и мир\" => :splendid, \"Отцы и дети\" => :abysmal, \"Идиот\" => :mediocre, \"Евгений Онегин\" => :amazing}"},
"29":{"lang":"RU","title":"Подсчет","chapter":"N","answer":".+","ok":"Ура!","error":"","text":"<p>Одна из потрясающих вещей, которую мы использовали это <strong>block(блок)</strong>. Мы изучим подробнее в\nэтом и следующем уроке. Но, в основном, блок - это немного кода на Ruby, окруженного фигурными\nскобками.</p>\n\n<p>Давайте попробуем создать другой блок:</p>\n\n<pre><code>5.times { print &quot;Ура! &quot; }\n</code></pre>\n\n<p>Блоки всегда привязаны к методам. Как метод <strong>times</strong>, который берет блок и запускает\nкод снова и снова. (В нашем примере: пять раз.)</p>\n","load_code":""},
"30":{"lang":"RU","title":"Есть минутка?","chapter":"N","answer":"[0-9]$","ok":"Ты сделал все верно!","error":"Выполните блок 0-9 раз","text":"<p>Как мы видели в первом примере с блоком (при подсчете оценок), мы можем передать значение блоку. Значение, которое\nвставляется определяется методом, который запускает блок.</p>\n\n<p>Значения, которые <strong>принимает</strong> блок, помещаются в имя переменной в начале блока,\nмежду двумя символами pipe: |</p>\n\n<p>Попробуем это с помощью этого блока:</p>\n\n<pre><code>5.times { |time|\n    puts time\n}\n</code></pre>\n\n<p>Здесь метод <strong>.times</strong> отдает значение переменной <strong>|time|</strong>. Но имейте в виду, что эта переменная известна\nтолько внутри блока</p>\n\n<blockquote>\n<p>Заметили, что вы можете писать код на нескольких строках?</p>\n</blockquote>\n","load_code":""},
"31":{"lang":"RU","title":"Подводя итоги #4","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Этот урок был немного длиннее. Вы, вероятно, потратили на три минуты больше на его изучение:</p>\n\n<h3>Словари</h3>\n\n<p>Самый простой пример словаря: <strong>{}</strong></p>\n\n<h3>Символы</h3>\n\n<p>Крошечные, эффективные кодовые слова с двоеточием, например: <strong>:splendid</strong></p>\n\n<h3>Блоки</h3>\n\n<p>Куски кода, которые можно привязать ко многим методам Ruby. Вот код, который вы использовали для\nсоздания таблицы оценок:\n    <strong>books.values.each { |rate| ratings[rate] += 1 }</strong></p>\n\n<h3>Далее</h3>\n\n<p>В следующих уроках мы еще глубже погрузимся в методы</p>\n","load_code":""},
"32":{"lang":"RU","title":"Быть или не быть","chapter":"N","answer":"","ok":"","error":"","text":"<p>Одна маленькая деталь, которую мы не обсудили - это аргументы методов. Помните,\nкак мы меняли содержимое поэмы, используя этот метод:\n<strong>poem.gsub(&ldquo;тост&rdquo;, &ldquo;медовик&rdquo;)</strong></p>\n\n<p>Метод gsub требует 2 аргумента, которые мы вставили как строки между двух круглых\nскобок. Аргументы сообщают методу, что именно ему делать.</p>\n\n<h3>Круглые скобки</h3>\n\n<p>На самом деле, в большинстве случаев Ruby не против, если вы опустите скобки. Таким образом, это\nтоже сработает:</p>\n\n<p><strong>poem.gsub &ldquo;toast&rdquo;, &ldquo;honeydew&rdquo;</strong></p>\n\n<p>Мы также уже использовали и другой метод с параметром. Много раз. Но это не так очевидно.</p>\n\n<pre><code>puts &quot;Hello&quot;\nputs(&quot;Hello&quot;)\n</code></pre>\n\n<p>Ага, <strong>puts</strong> тоже метод. Использование puts с круглыми скобками или без Ruby не важно, но\nвариант без скобок проще читать и немного экономит время набора кода!</p>\n\n<blockquote>\n<p>Поэтому я предполагаю, что вывод состоит в том, что вы можете делать все, что угодно, с круглыми скобками, пока\nкод читается красиво.</p>\n</blockquote>\n\n<p>Хотите немного Шекспира? Читайте дальше.</p>\n","load_code":"poem = \"Мой тост вылетел из моей руки\\n И мой тост отправился на Луну. \\n Ура, Ура, Ура \\n\""},
"33":{"lang":"RU","title":"Укрощение строптивого","chapter":"N","answer":"tame","ok":"Хорошо, хорошо!","error":"","text":"<p>Вы уже знаете, как использовать Ruby. Я имею в виду, что ты уже постиг основы.\nДалее тебе нужно изучить больше методов и попробовать более сложные блоки.</p>\n\n<p>Но мы кое-что еще не обсудили. Создание собственных методов.\n<strong>Хм!</strong> Давайте займемся этим.</p>\n\n<p>В то время, как Ruby имеет встроенные методы (такие, как puts, sort, times), вы можете определить\nсвои собственные методы. Зачем? Вот 2 причины.</p>\n\n<h3>Сделать свою программу короче</h3>\n\n<p>Если вы используете одно и тоже более чем в одном месте кода, то будет намного проще, если\nвыделить это в новый метод. Это сделает код короче.</p>\n\n<h3>Сделать свой код более читаемым</h3>\n\n<p>Предположим, что ваша программа должна делать много разных вещей.\nВы <strong>можете</strong> записать весь код в один длинный кусок. Но было бы очень сложно\nпрочитать и понять этот код позже.</p>\n\n<p>Вместо этого вы должны разбить свой код на методы и дать каждому из них\nпонятное английское имя. Вы поблагодарите себя позже.</p>\n\n<p>Итак, как мы определяем метод? Вот так:</p>\n\n<pre><code>def tame( number_of_shrews )\nend\n</code></pre>\n","load_code":""},
"34":{"lang":"RU","title":"В Ruby, Def Leppard означает: определить метод Leppard *","chapter":"N","answer":"^tame","ok":"Tame is not lame","error":"","text":"<p>Эй, хорошо, ты это сделал. Вы создали свой собственный метод. Вы начали с def, за которым следует имя метода.\nИ список аргументов, которые будут нужны методу. Это не слишком страшно и опасно!\nВсе, что нам нужно сделать, это заполнить его кодом на Ruby и закончить с ним.</p>\n\n<p>Вот код:</p>\n\n<pre><code>def tame( number_of_shrews )\n  number_of_shrews.times {\n    puts &quot;Tamed a shrew&quot;\n  }\nend\n</code></pre>\n\n<blockquote>\n<p><strong>P.S.</strong><br>\nЕсли вы не знаете это название, то прочтите\n<a href=\"http://en.wikipedia.org/wiki/Def_Leppard\" target=\"_blank\">Def Leppard</a>\nэто название известной Британской группы.</p>\n</blockquote>\n","load_code":""},
"35":{"lang":"RU","title":"Плод вашего собственного творения","chapter":"N","answer":"^Tamed a shrew","ok":"Вот и все!","error":"","text":"<p>Новый метод рожден. Попробуем его использовать:</p>\n\n<pre><code>tame 5\n</code></pre>\n","load_code":"def tame(number_of_shrews);number_of_shrews.times{puts \"Tamed a shrew\"};end;"},
"36":{"lang":"RU","title":"Давай и бери","chapter":"N","answer":"\\d+","ok":"На уровне! Браво!","error":"","text":"<p>Большинство методов не только требуют ввода некоторых параметров, но и возвращают что-то обратно.\nЯ немного изменил наш метод, чтобы он вернул вам значение. Попробуй:</p>\n\n<pre><code>def tame( number_of_shrews )\n  number_of_shrews.times {\n    puts &quot;Tamed a shrew&quot;\n  }\n  return number_of_shrews\nend\n\nputs tame(3)\n</code></pre>\n\n<h3>Возвращаемое значение</h3>\n\n<p>И, поскольку вы настолько продвинуты и способны, еще один совет:\nвы можете опустить слово <strong>return</strong> из последней строки метода.\nRuby автоматически вернет последнее значение, которое использовалось внутри метода.</p>\n\n<p>Так мы можем изменить последнюю строку на это: <strong>number_of_shrews</strong>.</p>\n\n<p>Но по-прежнему метод <strong>.times</strong> также может справиться с этой задачей.\nТак что наш новый метод делает то, что мы уже давно можем и без него!</p>\n","load_code":""},
"37":{"lang":"RU","title":"Кто здесь? Итоги #5 Снимите шляпу!","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Отлично, Отлично, Отлично!</p>\n\n<p>Круто! Круто! Круууууто! </p>\n\n<p>Вот что мы еще узнали:</p>\n\n<h3>Методы</h3>\n\n<p>Методы могут быть определены с помощью <strong>def</strong> и у них есть имя. Методы\nделают вашу программу короче и проще для чтения.</p>\n\n<h3>Параметры</h3>\n\n<p>У методов могут быть параметры</p>\n\n<h3>Возвращаемое значение</h3>\n\n<p>Методы зачастую возвращают какое-то значение</p>\n\n<h2>А сейчас</h2>\n\n<p>Готовы почитать немного Шекспира?</p>\n","load_code":""},
"38":{"lang":"RU","title":"Мир - наша устрица","chapter":"N","answer":"^\\{\\\"William","ok":"Хорошо, но читать тяжело!","error":"","text":"<p>До сих пор мы запускали программы, которые используют только те вещи, которые мы набрали сами.\nЭто классно, но сейчас эпоха интернета, а значит можно использовать эти данные.</p>\n\n<p>Много, много веб-сайтов в сети, а значит у всех них можно запросить информацию. Например:\nэта ссылка даст вам  все последние <a href=\"http://news.google.com/news/section?q=ruby&output=rss\" target=\"_blank\">Новости из Гугла</a>\nо Ruby.</p>\n\n<p>Ваш браузер скорее всего отобразит это красиво. Но если вы посмотрите на исходный код,\n(нажмите: control-U) вы увидите сложный текст в формате <strong>rss</strong>.</p>\n\n<h3>Форматы</h3>\n\n<p>Всего очень много форматов со сложными названиями в сети, такие как:\nhtml, xml and json. Ага, многие веб-сайты используют их.</p>\n\n<p>Я подготовил для вас метод, который выберет список полных работ Уильяма\nШекспира из Интернета.\n(Не волнуйтесь, что на самом деле это происходит с того же сервера, на котором работает этот веб-сайт, поэтому\nмы никого не беспокоим.)</p>\n\n<p>Получите данные с помощью:</p>\n\n<pre><code>get_shakey\n</code></pre>\n","load_code":"def get_shakey;JSON.parse(\"{\\\"William Shakespeare\\\": {\\\"1\\\": {\\\"title\\\": \\\"The Two Gentlemen of Verona\\\", \\\"finished\\\": 1591},\\\"2\\\": {\\\"title\\\": \\\"The Taming of the Shrew\\\", \\\"finished\\\": 1591},\\\"3\\\": {\\\"title\\\": \\\"Henry VI, Part 2\\\", \\\"finished\\\": 1591},\\\"4\\\": {\\\"title\\\": \\\"Henry VI, Part 3\\\", \\\"finished\\\": 1591},\\\"5\\\": {\\\"title\\\": \\\"Henry VI, Part 1\\\", \\\"finished\\\": 1592},\\\"6\\\": {\\\"title\\\": \\\"Titus Andronicus\\\", \\\"finished\\\": 1592},\\\"7\\\": {\\\"title\\\": \\\"Richard III\\\", \\\"finished\\\": 1593},\\\"8\\\": {\\\"title\\\": \\\"Edward III\\\", \\\"finished\\\": 1593},\\\"9\\\": {\\\"title\\\": \\\"The Comedy of Errors\\\", \\\"finished\\\": 1594},\\\"10\\\": {\\\"title\\\": \\\"Love's Labour's Lost\\\", \\\"finished\\\": 1595},\\\"11\\\": {\\\"title\\\": \\\"Love's Labour's Won\\\", \\\"finished\\\": 1596},\\\"12\\\": {\\\"title\\\": \\\"Richard II\\\", \\\"finished\\\": 1595},\\\"13\\\": {\\\"title\\\": \\\"Romeo and Juliet\\\", \\\"finished\\\": 1595},\\\"14\\\": {\\\"title\\\": \\\"A Midsummer Night's Dream\\\", \\\"finished\\\": 1595},\\\"15\\\": {\\\"title\\\": \\\"King John\\\", \\\"finished\\\": 1596},\\\"16\\\": {\\\"title\\\": \\\"The Merchant of Venice\\\", \\\"finished\\\": 1597},\\\"17\\\": {\\\"title\\\": \\\"Henry IV, Part 1\\\", \\\"finished\\\": 1597},\\\"18\\\": {\\\"title\\\": \\\"The Merry Wives of Windsor\\\", \\\"finished\\\": 1597},\\\"19\\\": {\\\"title\\\": \\\"Henry IV, Part 2\\\", \\\"finished\\\": 1598},\\\"20\\\": {\\\"title\\\": \\\"Much Ado About Nothing\\\", \\\"finished\\\": 1599},\\\"21\\\": {\\\"title\\\": \\\"Henry V\\\", \\\"finished\\\": 1599},\\\"22\\\": {\\\"title\\\": \\\"Julius Caesar\\\", \\\"finished\\\": 1599},\\\"23\\\": {\\\"title\\\": \\\"As You Like It\\\", \\\"finished\\\": 1600},\\\"24\\\": {\\\"title\\\": \\\"Hamlet\\\", \\\"finished\\\": 1601},\\\"25\\\": {\\\"title\\\": \\\"Twelfth Night\\\", \\\"finished\\\": 1601},\\\"26\\\": {\\\"title\\\": \\\"Troilus and Cressida\\\", \\\"finished\\\": 1602},\\\"27\\\": {\\\"title\\\": \\\"Sir Thomas More\\\", \\\"finished\\\": 1604},\\\"28\\\": {\\\"title\\\": \\\"Measure for Measure\\\", \\\"finished\\\": 1604},\\\"29\\\": {\\\"title\\\": \\\"Othello\\\", \\\"finished\\\": 1604},\\\"30\\\": {\\\"title\\\": \\\"All's Well That Ends Well\\\", \\\"finished\\\": 1605},\\\"31\\\": {\\\"title\\\": \\\"King Lear\\\", \\\"finished\\\": 1606},\\\"32\\\": {\\\"title\\\": \\\"Timon of Athens\\\", \\\"finished\\\": 1606},\\\"33\\\": {\\\"title\\\": \\\"Macbeth\\\", \\\"finished\\\": 1606},\\\"34\\\": {\\\"title\\\": \\\"Antony and Cleopatra\\\", \\\"finished\\\": 1606},\\\"35\\\": {\\\"title\\\": \\\"Pericles, Prince of Tyre\\\", \\\"finished\\\": 1608},\\\"36\\\": {\\\"title\\\": \\\"Coriolanus\\\", \\\"finished\\\": 1608},\\\"37\\\": {\\\"title\\\": \\\"The Winter's Tale\\\", \\\"finished\\\": 1611},\\\"38\\\": {\\\"title\\\": \\\"Cymbeline\\\", \\\"finished\\\": 1610},\\\"39\\\": {\\\"title\\\": \\\"The Tempest\\\", \\\"finished\\\": 1611},\\\"40\\\": {\\\"title\\\": \\\"Cardenio\\\", \\\"finished\\\": 1613},\\\"41\\\": {\\\"title\\\": \\\"Henry VIII\\\", \\\"finished\\\": 1613},\\\"42\\\": {\\\"title\\\": \\\"The Two Noble Kinsmen\\\", \\\"finished\\\": 1614}}}\");end;"},
"39":{"lang":"RU","title":"Благородные родственники","chapter":"N","answer":"^The Two Noble Kinsmen$","ok":"Так намного лучше.","error":"","text":"<p>Итак, теперь у нас есть список пьес из Интернета. Список был в формате json.\nК счастью для нас Ruby любезно предоставляет метод преобразования данных json в hash Ruby.\nМетод <em>get_shakey</em> сделает это за нас.</p>\n\n<p>Но так как структура json-данных сохраняется в hash, ее все-таки трудно читать.\nДавайте напишем метод для показа игр.</p>\n\n<p>Если вы внимательно изучите список пьес, вы увидите, что у него есть своего рода вложенный\nсостав. (Это действительно довольно распространено в данных, которые вы получаете из Интернета.)\nВыглядит так:</p>\n\n<ul>\n  <li>&ldquo;William Shakespeare&rdquo;\n  <ul>\n      <li>&ldquo;1&rdquo;\n      <ul>\n        <li>&ldquo;title&rdquo;: &ldquo;The Two Gentlemen of Verona&rdquo;</li>\n        <li>&ldquo;finished&rdquo;: 1591</li>\n      </ul>\n      </li>\n      <li>&ldquo;2&rdquo;\n      <ul>\n        <li>&ldquo;title&rdquo;: &ldquo;The Taming of the Shrew&rdquo;</li>\n        <li>&ldquo;finished&rdquo;: 1591</li>\n      </ul>\n      </li>\n      <li>&hellip;</li>\n  </ul>\n  </li>\n</ul>\n\n<p>Чтобы перечислить пьесы, нам сначала нужно получить доступ к верхнему элементу словаря «Уильям Шекспир» по его названию.\nЗатем мы должны <strong>iterate(&ldquo;шагать&rdquo;)</strong> по каждому элементу за ним.</p>\n\n<p>Ruby имеет метод для итерации. Он называется <strong>each</strong>. Мы видели это раньше, когда\nсоздавали нашу систему рейтинга книг.</p>\n\n<p>Все, что возвращает метод <strong>each</strong>, передается блоку:</p>\n\n<pre><code>s = get_shakey\n\ns[&quot;William Shakespeare&quot;].each { |key, val|\n  puts val[&quot;title&quot;]\n}\n</code></pre>\n","load_code":"prev"},
"40":{"lang":"RU","title":"Все вместе","chapter":"N","answer":"^4$","ok":"Ага, Шекспир написал 4 пьесы в 1591","error":"Ответ должен быть 4. Проверьте аргумент метода count_plays","text":"<p>Теперь предположим, что мы хотим знать имена и количество пьес, написанных Шекспиром\nв течение определенного года.</p>\n\n<p>Ruby позволяет нам выводить значения из словаря. Метод select использует блок, который позволяет нам\nопределить, что выбрать и вернуть найденное.</p>\n\n<p>Затем мы можем использовать результаты, возвращаемые <strong>select</strong> в методе <strong>each</strong>, как и раньше,\nпросто добавляя его после блока выбора. Это еще один пример цепочки методов, который мы видели\nраньше, когда делали стихотворение задом наперед.</p>\n\n<p>Я подготовил метод <strong>count_plays</strong> для вас. Посмотрим, сможете ли\nвы посчитать количество пьес, написанных Шекспиром в 1591:</p>\n\n<pre><code>def count_plays(year)\n  s = get_shakey\n\n  s[&quot;William Shakespeare&quot;]\n    .select { |k, v|\n      v[&quot;finished&quot;] == year\n    }.each { |key, val|\n      puts val[&quot;title&quot;]\n    }.count\nend\n\nputs count_plays(0)\n</code></pre>\n\n<p>Вы заметили, что я добавил метод count в самом конце всего метода. Так мы получим \nвозвращаемое значение метода <strong>count_plays</strong>.</p>\n\n<p>Есть и другой способ выстраивания цепочки. Видите одинокую строчку <strong>s = get_shakey</strong>.\nВы можете добавить <strong>[&ldquo;William Shakespeare&rdquo;].select { |k, v|</strong> в конец get_shakey\n(не обязательно здесь).</p>\n","load_code":"prev"},
"41":{"lang":"RU","title":"Все хорошо, что хорошо кончается","chapter":"N","answer":"All's Well That Ends Well","ok":"Верно","error":"Используйте 1605 как 2 параметр","text":"<p>Хорошо, мы получили некоторые данные из Интернета, мы выбрали то, что хотели, и распечатали это.\nЧто нужно улучшить? Мы могли бы напечатать результаты немного красивее. Как добавить год\nи выровнять названия и годы?</p>\n\n<p>Это значит требуется печать нескольких значений на одной строке. Ruby имеет удобный способ сделать\nэто. Это похоже на печать строки типа: _<em>puts «Привет, меня зовут Джимми» _</em>.\nНо вместо буквенного значения <em>Джимми</em> мы используем значение переменной.</p>\n\n<p>Сначала замените <strong>Джимми</strong> на <strong>#{}</strong>. Если Ruby видит символ #, а за ним символ {,\nто это означает,что до символа } идет имя переменной. \nТак, мы можем использовать: <strong>&ldquo;Привет, меня зовут #{name}&rdquo;</strong>.</p>\n\n<p>Изменим наш код немного:</p>\n\n<pre><code>def print_plays(year_from, year_to)\n  get_shakey[&quot;William Shakespeare&quot;]\n    .select { |k, v|\n      year_from &lt;= v[&quot;finished&quot;] &amp;&amp;\n      year_to   &gt;= v[&quot;finished&quot;]\n    }.each { |k, v|\n      puts &quot;#{v[&quot;title&quot;].ljust(30)} #{v[&quot;finished&quot;]}&quot;\n    }\nend\nprint_plays(1600, 1605)\n</code></pre>\n\n<p>Я добавил <strong>.ljust(30)</strong> к заголовку. В таком случае заголовок <em>имеет отступ</em> минимум\n30 символов. Так год выглядит опрятнее =)</p>\n\n<p>Посмотрите, изменится ли выход программы так, чтобы она показывала такие игры: 1600 -&gt; Как вам нравится\nВсе хорошо, что хорошо кончается? \nЭй, мы еще не закончили, но конец близок!</p>\n","load_code":"prev"},
"42":{"lang":"RU","title":"Если бы я знал, как принять решение","chapter":"N","answer":"","ok":"","error":"","text":"<p>Делать выбор в жизни бывает трудно, но не в Ruby. Тут есть удобные способы принять решение.</p>\n\n<pre><code>if 1 &lt; 2\n  puts &quot;Это правда: 1 меньше 2&quot;\nend\n</code></pre>\n\n<p>Ключевое слово <strong>if(если)</strong>. If может быть поставлен и до, и после метода. Как тут:</p>\n\n<pre><code>puts &quot;Это правда: 1 меньше 2&quot; if 1 &lt; 2\n</code></pre>\n\n<p><strong>If</strong> это метод, который требует 1 параметр. Этим параметром может быть любое выражение, которое\nвы хотите проверить. Результат выражения  <strong>true(правда)</strong> or <strong>false(ложь)</strong>.\nВот немного примеров:</p>\n\n<pre><code>5     &lt;= 10     # =&gt; true\n&#39;abc&#39; == &#39;def&#39;  # =&gt; false\ntrue            # =&gt; true\n123456          # =&gt; true\n0               # =&gt; true\nnil             # =&gt; false\n&#39;xyz&#39;.empty?    # =&gt; false\n&#39;a&#39; &gt; 5         # =&gt; error:\n                # comparison of String with\n                # Numeric failed\n</code></pre>\n\n<p><em>if выражение</em> может иметь много видов: сравнивать значения (1 &lt; 2),\nпеременные (a &lt; 1) и возвращаемые значения методов(&lsquo;xyz&rsquo;.empty?).</p>\n","load_code":""},
"43":{"lang":"RU","title":"И напоследок","chapter":"N","answer":"не равно 100$","ok":"Так лучше","error":"Это неправильно","text":"<p>Видите двойное равно <strong>&lsquo;abc&rsquo; == &lsquo;def&rsquo;</strong>?</p>\n\n<p>Это <strong>==</strong> означает <strong>проверка на равенство</strong>.\nОдиночное равно используется для присваивания значения переменной.</p>\n\n<p>Чтобы немного вас запутать: вы можете использовать присваивание как аргумент метода if:</p>\n\n<pre><code>a = 0\n\nif a = 100\n  puts &quot;Выражение верно, но а сейчас : #{a}&quot;\nelse\n  puts &quot;#{a} не равно 100&quot;\nend\n</code></pre>\n\n<p>Поменяйте = на == и посмотрите, что произойдет.</p>\n\n<p>Я вам гарантирую, что вы будете часто забывать поставить двойное равенство.</p>\n\n<h3>Иначе(else)</h3>\n\n<p>В коде я использовал else, это выполняется в случае\n<strong>if тестовое_выражение</strong> вычисляется как ложь(false).</p>\n\n<blockquote>\n<p>Больше информации вы можете почерпнуть\n<a href=\"http://www.ruby-doc.org/core/doc/syntax/control_expressions_rdoc.html\" target=\"_blank\">здесь</a>.</p>\n</blockquote>\n","load_code":""},
"44":{"lang":"RU","title":"Я голоден","chapter":"N","answer":"^Я не голоден","ok":"Да","error":"Без вариантов, я голоден в 10 утра!","text":"<p>Это прекрасно, но имей ввиду, что ты не знал Ruby всего 15 минут назад!</p>\n\n<p>Давай теперь объединим все наши полученные навыки:\nДавайте определим 2 метода: </p>\n\n<pre><code>def hungry?(time_of_day_in_hours)\n  puts &quot;Я голоден&quot;\n  true\nend\n\ndef eat_an(what)\n  puts &quot;Я ем #{what}\\n&quot;\nend\n\neat_an &#39;яблоко&#39; if hungry?(14)\n\neat_an &#39;яблоко&#39; if hungry?(10)\n</code></pre>\n\n<p>Попробуйте изменить  метод <strong>hungry?</strong> так, чтобы он печатал <strong>&ldquo;Я не голоден&rdquo;</strong> и возвращал false\nкогда время меньше 10.</p>\n","load_code":""},
"45":{"lang":"RU","title":"Итоги #6 Что значит издалека?","chapter":"Y","answer":"\\{\\}","ok":"Ага, это пустой словарь","error":"","text":"<p>Вы 6-го уровня Ruby клирик. Я имею ввиду, что проделана отличная работа. Давайте подведем итоги:</p>\n\n<h3>Данные</h3>\n\n<p>Ты загрузил немного данных из интернета и организовал их в структуру.</p>\n\n<h3>Iterating (шагание)</h3>\n\n<p>Вы прошли по всем элементам словаря, а также создали цепочку методов</p>\n\n<h3>Красивый вывод</h3>\n\n<p>И если этого недостаточно, то вы научились делать красивый вывод.\nЭто ведь настоящая программа!</p>\n\n<h3>Если(IF)</h3>\n\n<p>Научились использовать if и else</p>\n\n<h2>Итак</h2>\n\n<p>Что может быть дальше? Что вы, возможно, должны узнать сейчас?\nХа, это лучшая часть. Вы прошли столь долгий путь, что мы собираемся\nизучить классы. Еще два коротких урока, и все готово.</p>\n\n<p>Ранее мы создавали словарь так:</p>\n\n<pre><code>Hash.new\n</code></pre>\n","load_code":""},
"46":{"lang":"RU","title":"Не школьный класс, а работающий","chapter":"N","answer":"","ok":"","error":"","text":"<p>Вы уже видели пустые фигурные скобки. {} это сокращение Hash.new. Метод new используется, чтобы создавать объекты\nопределенного класса. Воспринимайте &ldquo;class&rdquo; в смысле &ldquo;работающий класс&rdquo; &mdash; какая-то особенная группа,\nделающая одну работу и в одинаковых футболках.\nЧто используется в классах?</p>\n\n<h3>Blurbalizer<sup>TM</sup></h3>\n\n<p>Прикольная идея для нового приложения. Это будет новая платформа для обмена сообщениями.\nВы хотите приложение, где люди могут обмениваться короткими сообщениями. Вы называете эти сообщения Blurbs<sup>TM</sup>.\nBlurb<sup>TM</sup> имеет максимальную длину 40. Давайте сделаем еще настроение сообщения.</p>\n\n<!---Интернет действительно привел нас к тому, что даже в банкротстве люди отправляют улыбки, используя смайлики -->\n\n<h3>Где начать?</h3>\n\n<p>Ну, вы можете сохранить записи Blurbs<sup>TM</sup> в json-файле, верно?\nНо как бы вы отслеживали содержание записи и время ее публикации?\nИ когда вы загрузите файл, как он будет выглядеть в Ruby?\nЭто будет словарь? Или массив? Или массив массивов? Или что-то другое?</p>\n\n<h3>Класс</h3>\n\n<p>Я уверен, что вы должны использовать класс. Вы уже знаете некоторые из них:\nсловарь, массив, строка.</p>\n\n<p>Создадим новый класс:</p>\n\n<pre><code>class Blurb\nend\n</code></pre>\n","load_code":""},
"47":{"lang":"RU","title":"Приложения делаются","chapter":"N","answer":"","ok":"","error":"","text":"<p>Мы открыли новый Blurb<sup>TM</sup> класс. Чем наполнен ваш блог?\nВерно, контентом. Также временем, когда Blurb<sup>TM</sup> был опубликован. И настроением.</p>\n\n<p>Хорошо, так что у вас есть первая строка класса, вот и все:</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\nend\n</code></pre>\n\n<p>Имена классов всегда с большой буквы.</p>\n","load_code":""},
"48":{"lang":"RU","title":"Аксессоры это обособленные элементы","chapter":"N","answer":"Blurb:","ok":"Мой первый Blurb","error":"","text":"<p>Привет. У тебя есть новый Blurb<sup>TM</sup> класс.</p>\n\n<p>В определении класса вы использовали метод, называющийся attr_accessor(аксессор).\nВообще много атрибутов класса, которые так или иначе его меняют.\nАтрибуты - это всего лишь переменные связанные с классом.</p>\n\n<p>Думайте так. Класс - это человек. Это звездное человеческое существо.\nА атрибуты - это его конечности, разные части собираются в тело, а другие люди могут взять этого человека за руку и поздороваться.</p>\n\n<h3>Сейчас</h3>\n\n<p>Чтобы создать Blurb<sup>TM</sup> и наполнить данными напишите:</p>\n\n<pre><code>blurb1 = Blurb.new\nputs blurb1\nblurb1.content = &quot;Today Mount Hood Was Stolen!&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;end"},
"49":{"lang":"RU","title":"Объект, этот аккуратный маленький пакет","chapter":"N","answer":"Blurb:","ok":"Blurb обновлен","error":"","text":"<p>А теперь поменяй атрибуты нашего Blurb<sup>TM</sup>:</p>\n\n<pre><code>blurb1.time = Time.now\nblurb1.mood = :sick\n\nputs blurb1\n</code></pre>\n","load_code":"prev;blurb1=Blurb.new;blurb1.content=\"Today Mount Hood Was Stolen!\""},
"50":{"lang":"RU","title":"Ускоряемся","chapter":"N","answer":"^\\d{4}","ok":"Запомнили :)","error":"","text":"<p>Круто, новое приложение потрясающее. Хей, давай немного упростим?\nВы всегда хотите ставить время вашему Blurb<sup>TM</sup> так?.</p>\n\n<p>Вы всего лишь хотите писать контент?</p>\n\n<p>Добавим метод <strong>инициализации</strong> в наш класс. Этот метод будет всегда вызываться, когда новый Blurb<sup>TM</sup>\nсоздается.\nТакже мы можем установить максимальную длину Blurb<sup>TM</sup> контента в 40 символов.</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\n\n  def initialize(mood, content=&quot;&quot;)\n    @time    = Time.now\n    @content = content[0..39]\n    @mood    = mood\n  end\nend\n\nBlurb.new.time\n</code></pre>\n\n<p>(Этот параметр <strong>content=&ldquo;&rdquo;</strong> используется, чтобы было известно, что это строка и никакой другой параметр не мог инициализировать его.)</p>\n","load_code":""},
"51":{"lang":"RU","title":"Вы научили ваше приложение отвергать бесполезные вещи","chapter":"N","answer":"Blurb:","ok":"Blurb добавлен","error":"","text":"<p>Вы заметили, что мы используем символ &ldquo;собаки&rdquo; внутри класса? (@time).</p>\n\n<p><strong>Снаружи</strong> класса мы используем аксессоры:</p>\n\n<blockquote>\n<p><strong>blurb.time = Time.now</strong></p>\n</blockquote>\n\n<p>но <strong>внутри</strong> мы используем <strong>переменные объекта</strong>:</p>\n\n<blockquote>\n<p><strong>@time = Time.now</strong></p>\n</blockquote>\n\n<p>Это одно и тоже, но может использоваться в разных местах вашей программы.</p>\n\n<h3>Создадим другой Blurb<sup>TM</sup></h3>\n\n<p>Когда другой Blurb<sup>TM</sup> создан, метод инициализации используется для проверки любого\nаргумента к методу new.</p>\n\n<p>Ох, нужно еще 2 аргумента:</p>\n\n<pre><code>blurb2 = Blurb.new :confused, &quot;Не могу поверить, Маунт-Худ был украден!&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end;blurb1=Blurb.new(:sick,\"Today Mount Hood Was Stolen!\")"},
"52":{"lang":"RU","title":"А жирафы на месте ИТОГИ #7","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Ага, ты здесь. И все еще учишься. Мы по-прежнему будем делать ваше приложение реальным,\nно пока давайте посмотрим результаты, хорошо?</p>\n\n<h3>Классы</h3>\n\n<p>Все в Ruby - это объекты. Классы объясняют объекты как независимые рабочие элементы.\nНапример, вы создали несколько Blurb<sup>TM</sup> объектов, а эти объекты ведут себя так же<br>\nкак любой объект класса Blurb.</p>\n\n<p>Другими словами: Вы называете их Blurb объекты.\nВы можете использовать классы как в реальной жизни.</p>\n\n<h3>Аксессоры</h3>\n\n<p>Аксессоры - это переменные, связанные с классом, но используются <strong>снаружи</strong> объекта.\n(blurb2.time = Time.now)</p>\n\n<h3>Переменные объекта</h3>\n\n<p>Это то же самое, что и аксессоры, но используются <strong>внутри</strong> объекта.\n(@time = Time.now)</p>\n","load_code":"prev;blurb2=Blurb.new :confused, \"Не могу поверить, Маунт-Худ был украден!\""},
"53":{"lang":"RU","title":"Ваш собственный сад","chapter":"N","answer":"Blurbalizer:","ok":"Приложение создано","error":"","text":"<p>Ладно, давай обернемся, малыш. Вот последняя глава эпической истории познания «Try Ruby»!\nТеперь, когда у вас есть понимание, как все это работает, как вы собираетесь использовать это?\nТы отличный человек (один из моих любимых), но тебе нужно руководство.</p>\n\n<h3>Давай закончим наше приложение</h3>\n\n<p>У вас есть записи приложений, но нет приложения.\nПо-прежнему нужно место, где хранить все Blurbs<sup>TM</sup> и упорядочить их.</p>\n\n<p>Угадайте что, мы собираемся использовать другой класс. Я дал весь код для нового класса за один раз.\nТолько потрать время, чтобы изучить его.\nЯ не тороплюсь, я буду ждать тебя на следующем уроке.</p>\n\n<pre><code>class Blurbalizer\n  def initialize(title)\n    @title  = title\n    @blurbs = [] # Пустой массив\n                 # для хранения Blurbs\n  end\n\n  def add_a_blurb(mood, content)\n    # &lt;&lt; означают добавить в конец массива\n    @blurbs &lt;&lt; Blurb.new(mood, content)\n  end\n\n  def show_timeline\n    puts &quot;Blurbify: #{@title} has #{@blurbs.count} Blurbs&quot;\n\n    @blurbs.sort_by { |t|\n      t.time\n    }.reverse.each { |t|\n      puts &quot;#{t.content.ljust(40)} #{t.time}&quot;\n    }\n  end\nend\n\nmyapp = Blurbalizer.new &quot;The Big Blurb&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end"},
"54":{"lang":"RU","title":"Про что это Blurb?","chapter":"N","answer":"Today","ok":"Ок!","error":"","text":"<p>И вот результат. Вы поняли, что в коде класс Blurbalizer<sup>TM</sup> делает?</p>\n\n<blockquote>\n<p>В Blurbalizer<sup>TM</sup> есть 2  <strong>метода</strong> (add_a_blurb and show_timeline).\nВы можете использовать метод вне класса, также как и с аксессорами.</p>\n</blockquote>\n\n<p>Самое время, чтобы начать использовать Blurbalizer<sup>TM</sup>. Я уже загрузил несколько Blurbs<sup>TM</sup> для тебя,\nно добавь еще свой сам.</p>\n\n<p>Мы больше не создаем Blurbs<sup>TM</sup> напрямую, но мы используем метод add_a_blurb из класса \nBlurbalizer<sup>TM</sup>. Теперь мы можем быть уверены, что все наши Blurbs<sup>TM</sup> хранятся в\nобъекте myapp.</p>\n\n<pre><code>myapp.add_a_blurb :moody, &quot;Добавь Blurb сюда&quot;\n\nmyapp.show_timeline\n</code></pre>\n","load_code":"prev;class Blurbalizer;attr_reader :title;def initialize(title);@title=title;@blurbs=[];end;def add_a_blurb(mood, content);@blurbs << Blurb.new(mood, content);@blurbs.each {|t| t.time -= 73};end;def show_timeline;puts \"Blurbalizer: #{@title} has #{@blurbs.count} Blurbs\\n\";@blurbs.sort_by { |t| t.time}.reverse.each { |t| puts \"#{t.content.ljust(40)} #{t.time}\"};end;end;myapp = Blurbalizer.new \"The Big Blurb\";myapp.add_a_blurb :sick,\"Today Mount Hood Was Stolen!\";myapp.add_a_blurb :confused,\"I can not believe Mt. Hood was stolen!\";myapp.add_a_blurb :dazed,\"I am speechless!\";myapp.add_a_blurb :mad,\"It was stolen by a giraffe !!\";myapp.add_a_blurb :sad,\"I Left my Hoodie on the Mountain!\";myapp.add_a_blurb :mad,\"I am never going back to that mountain.\""},
"55":{"lang":"RU","title":"Это все про комбинирование","chapter":"N","answer":":-|","ok":"Угрюмо!","error":"","text":"<p>Некоторые интересные вещи можно сделать с помощью простых частей Ruby, особенно когда вы их объединяете\nвместе в нечто новое.</p>\n\n<p>Здесь у нас есть приложение, состоящее из класса, содержащего другой класс.\nЭто называется объектно-ориентированное программирование (ООП)</p>\n\n<p>Мы приступаем к  <strong>последнему заданию</strong> на TryRuby. Если хотите, то можете добавить\nбольше интересного в Blurbalizer<sup>TM</sup>.</p>\n\n<p>Может вы захотите выводить улыбающийся смайлик в методе <strong>show_timeline</strong>. Вы должны добавить\n<em>модифицированный</em> метод в класс Blurb<sup>TM</sup> и затем использовать это в методе <em>show_timeline</em>:</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\n\n  def initialize(mood, content=&quot;&quot;)\n    @time    = Time.now\n    @content = content[0..39]\n    @mood    = mood\n  end\n\n  def moodify\n    if    @mood == :sad\n      return &quot;:-(&quot;\n    elsif @mood == :happy\n      return &quot;:-)&quot;\n    # Добавь другой смайлик сюда\n    end\n\n    # Смайлик по умолчанию\n    &quot;:-|&quot;\n  end\nend\n\nclass Blurbalizer\n  def initialize(title)\n    @title  = title\n    @blurbs = []\n  end\n\n  def add_a_blurb(mood, content)\n    @blurbs &lt;&lt; Blurb.new(mood, content)\n  end\n\n  def show_timeline\n    puts &quot;Blurbalizer: #{@title} содержит #{@blurbs.count} Blurbs&quot;\n\n    @blurbs.sort_by { |t|\n      t.time\n    }.reverse.each { |t|\n      puts &quot;#{t.content.ljust(40)} #{t.time}&quot;\n    }\n  end\nend\n\nmyapp.show_timeline\n</code></pre>\n","load_code":"prev"},
"56":{"lang":"RU","title":"ИТОГИ #8","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Этот последний раздел потребовался, чтобы дать вам несколько указаний о том, как вы можете использовать Ruby.</p>\n\n<p>Если вам понравилось, то можете продолжить в <a href=\"/playground\">TryRuby Playground</a>\nили скачать и установить Ruby:\n<a href=\"https://www.ruby-lang.org/en/downloads/\" target=\"_blank\">ruby-lang.org</a></p>\n\n<p>Когда Ruby будет установлен, создайте новый файл <em>my_first_program.rb</em>, используя\nтекстовый редактор, добавьте немного кода на Ruby code и затем открыв терминал или командную строку наберите:</p>\n\n<pre><code>ruby my_first_program.rb\n</code></pre>\n\n<h2>Празднуйте</h2>\n\n<p>Вы действительно заслуживаете двухслойный торт с двойной двойной глазурью и парня, играющего на одной из этих крутых гитар, которая является двойной гитарой.\nЯ имею в виду, что ты закончил, ты действительно сделал это! Не сомневайтесь в этом!</p>\n\n<h2>Больше информации</h2>\n\n<p>На этом сайте есть еще <a href=\"/articles\">статьи</a>, в которых вы можете почерпнуть что-то полезное\nдля себя.</p>\n","load_code":"def ruby(f);puts \"Go to www.ruby-lang.org to download Ruby\";end;class K;attr_reader :rb;end;my_first_program=K.new"}}